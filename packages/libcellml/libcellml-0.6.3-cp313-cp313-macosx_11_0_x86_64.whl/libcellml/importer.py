# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _importer
else:
    import _importer

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import libcellml.logger
import libcellml.types
import libcellml.strict
class StringPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _importer.StringPair_swiginit(self, _importer.new_StringPair(*args))
    first = property(_importer.StringPair_first_get, _importer.StringPair_first_set)
    second = property(_importer.StringPair_second_get, _importer.StringPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _importer.delete_StringPair

# Register StringPair in _importer:
_importer.StringPair_swigregister(StringPair)

# libCellML generated wrapper code starts here.

class Importer(libcellml.logger.Logger, libcellml.strict.Strict):
    r"""Manages all importing operations between CellML models."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _importer.delete_Importer

    def flattenModel(self, model):
        r"""Instantiate all imported components and units and return a self-contained model."""
        return _importer.Importer_flattenModel(self, model)

    def resolveImports(self, model, basePath):
        r"""
        Resolves all imports in this model.

        Resolves all component and units imports by loading the
        models from local disk through relative URLs. The ``baseFile`` is used to
        determine the full path to the source model relative to this one.
        """
        return _importer.Importer_resolveImports(self, model, basePath)

    def libraryCount(self):
        r"""Returns the number of models loaded into the importer's library."""
        return _importer.Importer_libraryCount(self)

    def library(self, *args):
        r"""
        Returns the model instance stored at the given URL in the library.
        The URL string must be the absolute path to the document, including both the filename
        and the baseFile path.
        """
        return _importer.Importer_library(self, *args)

    def key(self, index):
        r"""
        Returns a string corresponding to the key at which a model is stored in the
        library by index, or an empty string if the index is out of range.
        """
        return _importer.Importer_key(self, index)

    def addModel(self, model, key):
        r"""
        Manually add a local model instance into the library under the URL key provided.
        Returns True if the model was added, and False if the URL key already exists.
        """
        return _importer.Importer_addModel(self, model, key)

    def replaceModel(self, model, key):
        r"""
        Manually replace an existing library model instance with the one provided.
        Returns True if the URL key is found in the library and the model is added,
        and False if the URL key does not exist.
        """
        return _importer.Importer_replaceModel(self, model, key)

    def clearImports(self, model):
        r"""Clears the links with other models from all import sources."""
        return _importer.Importer_clearImports(self, model)

    def removeAllModels(self):
        r"""Removes all models from the library."""
        return _importer.Importer_removeAllModels(self)

    def addImportSource(self, importSource):
        r"""Manually add an ImportSource to the Importer."""
        return _importer.Importer_addImportSource(self, importSource)

    def importSourceCount(self):
        r"""Return the number of ImportSource items in the Importer."""
        return _importer.Importer_importSourceCount(self)

    def importSource(self, index):
        r"""Retrieve an ImportSource by index."""
        return _importer.Importer_importSource(self, index)

    def removeImportSource(self, *args):
        r"""Remove an ImportSource from the Importer by index or reference."""
        return _importer.Importer_removeImportSource(self, *args)

    def removeAllImportSources(self):
        r"""Remove all ImportSource items from the Importer."""
        return _importer.Importer_removeAllImportSources(self)

    def hasImportSource(self, importSource):
        r"""Test whether this Importer already contains the given ImportSource."""
        return _importer.Importer_hasImportSource(self, importSource)

    def __init__(self, *args):
        _importer.Importer_swiginit(self, _importer.new_Importer(*args))

# Register Importer in _importer:
_importer.Importer_swigregister(Importer)

