{"version":3,"file":"lib_index_js.9881975213742308bb7e.js","mappings":";;;;;;;;;;;;;;;;;AAAmD;AACjB;AAClC,oBAAoB,UAAU;AAC9B,wCAAwC,+CAAQ;AAChD,kCAAkC,+CAAQ;AAC1C,IAAI,gDAAS;AACb,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,2CAA2C,0DAAmB,CAAC,uDAAc;AAC7E,oBAAoB,0DAAmB,UAAU,SAAS,wBAAwB;AAClF,wBAAwB,0DAAmB;AAC3C,uCAAuC,0DAAmB,CAAC,4CAAG,IAAI,SAAS,wDAAwD;AACnI;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA,mCAAmC,0DAAmB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,SAAS;AACT,KAAK;AACL,YAAY,0DAAmB,CAAC,4CAAK,IAAI,sFAAsF,kBAAkB,WAAW,4DAA4D;AACxN;AACA;AACA;AACA;AACA;AACA,0FAA0F,YAAY,yHAAyH;AAC/N;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,aAAa,wCAAwC;AACrD;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;ACxDE;AACE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,6BAA6B,mDAAmD;AAChF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,wBAAwB,0DAAmB,UAAU,SAAS,sCAAsC;AACpG,4BAA4B,MAAM;AAClC,aAAa;AACb;AACA;AACA,4BAA4B,MAAM;AAClC;AACA,8BAA8B,IAAI,IAAI,MAAM;AAC5C,gCAAgC,MAAM,YAAY,IAAI;AACtD,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA,wBAAwB,UAAU;AAClC;AACA;AACA,YAAY,0DAAmB,CAAC,4CAAI,IAAI,kLAAkL;AAC1N;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;;ACvDe;AAC3C;AACA;AACA;AACA,6BAA6B,qDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAM;AACd;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjDoD;AACM;AACF;AACF;AACU;AACzD,sBAAsB,8DAAO;AACpC;AACA,YAAY,sDAAe;AAC3B,CAAC;AACM,yBAAyB,8DAAO;AACvC;AACA,YAAY,yDAAkB;AAC9B,CAAC;AACM,qBAAqB,8DAAO;AACnC;AACA,YAAY,qDAAc;AAC1B,CAAC;AACM,oBAAoB,8DAAO;AAClC;AACA,YAAY,oDAAa;AACzB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBqE;AACD;AACpB;AACG;AACC;AACU;AACL;AACP;AACC;AACA;AACN;AACK;AACnD;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAe,EAAE,oEAAe,EAAE,8DAAS,EAAE,yEAAgB,EAAE,oEAAgB;AAC9F,cAAc,4DAAuB;AACrC;AACA;AACA,4BAA4B,uDAAiB;AAC7C;AACA;AACA;AACA;AACA,4BAA4B,+DAAa,GAAG,WAAW;AACvD;AACA;AACA;AACA;AACA,6EAA6E,WAAW;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAoB;AACtD;AACA;AACA,mCAAmC,+DAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,0CAA0C;AAC7G;AACA;AACA;AACA;AACA;AACA,mEAAmE,sBAAsB;AACzF;AACA;AACA;AACA;AACA,aAAa;AACb,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,8EAA8E,OAAO;AACrF,SAAS;AACT;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAuB,EAAE,oEAAgB,EAAE,8DAAS;AACnE;AACA;AACA;AACA;AACA;AACA,sBAAsB,6BAA6B,IAAI,6BAA6B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0CAA0C,6DAAe,GAAG,SAAS;AACrE;AACA;AACA;AACA;AACA,wCAAwC,6DAAsB;AAC9D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,yEAAyE,WAAW,GAAG;AACvF;AACA;AACA,wEAAwE,wBAAwB;AAChG;AACA;AACA,qFAAqF,iBAAiB,0DAA0D,YAAY,aAAa,QAAQ,sCAAsC,QAAQ,8CAA8C,QAAQ,gDAAgD,aAAa;AAClW;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,2DAAS;AACxE;AACA,4CAA4C,kEAAU;AACtD;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;AC3QoB;AAC3C;AACA;AACA;AACO;AACP;AACA,oCAAoC,qDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvDyC;AACf;AACO;AACC;AACQ;AACC;AAC0B;AACrE;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACO,mCAAmC,mDAAM;AAChD;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB,EAAE,oBAAoB,GAAG;AACrE;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAmB,CAAC,4CAAG,IAAI,uBAAuB,0DAAmB,CAAC,gDAAY,UAAU,8CAA8C,YAAY,gDAAgD;AACpO;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAmB,CAAC,4CAAG,IAAI,uBAAuB,0DAAmB,CAAC,6CAAS,UAAU,sBAAsB,YAAY,gDAAgD;AACrM,oCAAoC,0DAAmB,CAAC,4CAAK,IAAI,uCAAuC,0DAAmB,UAAU,2BAA2B,mBAAmB,qGAAqG;AACxR;AACA;AACA,0BAA0B,0DAAmB,CAAC,4CAAG,IAAI,uBAAuB,0DAAmB,CAAC,6CAAS,UAAU,8CAA8C,YAAY,gDAAgD;AAC7N,oCAAoC,0DAAmB,CAAC,4CAAK,IAAI,6DAA6D,0DAAmB,UAAU,2BAA2B,6DAA6D,MAAM,MAAM,MAAM,MAAM,kBAAkB;AAC7R;AACA;AACA,0BAA0B,0DAAmB,CAAC,4CAAG,IAAI,uBAAuB,0DAAmB,CAAC,6CAAS,UAAU,8CAA8C,YAAY,gDAAgD;AAC7N,4BAA4B,0DAAmB,CAAC,4CAAG,IAAI,uBAAuB,0DAAmB,CAAC,6CAAS,UAAU,8CAA8C,YAAY,gDAAgD;AAC/N,6BAA6B,0DAAmB,CAAC,4CAAG,IAAI,uBAAuB,0DAAmB,CAAC,2CAAO,UAAU,8CAA8C,YAAY,gDAAgD;AAC9N,4BAA4B,0DAAmB,CAAC,4CAAG,IAAI,gGAAgG,iDAAiD,SAAS,0DAAmB,CAAC,6CAAS,UAAU,8CAA8C,8BAA8B,gDAAgD;AACpX;AACA;AACA;AACA;AACA,uCAAuC,0DAAmB,CAAC,qDAAY,IAAI,mBAAmB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0DAAmB,CAAC,4CAAG,IAAI,uBAAuB,0DAAmB,CAAC,4CAAQ,UAAU,8CAA8C,YAAY,gDAAgD;AAC7O;AACA,wCAAwC,0DAAmB,CAAC,uDAAc;AAC1E,wBAAwB,0DAAmB,CAAC,iDAAQ,IAAI,mBAAmB;AAC3E;AACA;AACA;AACA,0BAA0B,0DAAmB,CAAC,4CAAG,IAAI,iBAAiB;AACtE,mCAAmC,0DAAmB;AACtD;AACA;AACA,QAAQ,uDAAe,CAAC,0DAAmB,UAAU,SAAS,wDAAwD;AACtH,YAAY,0DAAmB,UAAU,SAAS,2GAA2G;AAC7J,gBAAgB,0DAAmB,UAAU,SAAS,qDAAqD;AAC3G;AACA;AACA;AACA;AACA,gBAAgB,0DAAmB;AACnC,YAAY,0DAAmB;AAC/B,YAAY,0DAAmB,CAAC,4CAAO,IAAI,SAAS,mBAAmB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB,kBAAkB;AAClB,oBAAoB;AACpB,mBAAmB;AACnB,oBAAoB;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;AC7K3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjE0C;AACnC,oCAAoC,oDAAK;AAChD;AACA;AACA;AACO,6BAA6B,oDAAK","sources":["webpack://@amphi/pipeline-log-console/./lib/DataView.js","webpack://@amphi/pipeline-log-console/./lib/DocumentView.js","webpack://@amphi/pipeline-log-console/./lib/handler.js","webpack://@amphi/pipeline-log-console/./lib/icons.js","webpack://@amphi/pipeline-log-console/./lib/index.js","webpack://@amphi/pipeline-log-console/./lib/kernelconnector.js","webpack://@amphi/pipeline-log-console/./lib/logconsole.js","webpack://@amphi/pipeline-log-console/./lib/manager.js","webpack://@amphi/pipeline-log-console/./lib/tokens.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { Table, Tag } from 'antd';\nconst DataView = ({ htmlData }) => {\n    const [dataSource, setDataSource] = useState([]);\n    const [columns, setColumns] = useState([]);\n    useEffect(() => {\n        const { data, headers } = htmlToJson(htmlData);\n        setDataSource(data);\n        setColumns(headers.map((header, index) => {\n            // Extract the type in parentheses at the end of the header\n            const matches = header.match(/^(.*)\\s\\(([^)]+)\\)$/); // Match pattern \"ColumnName (type)\"\n            const columnName = matches ? matches[1] : header;\n            const columnType = matches ? matches[2] : null;\n            return {\n                title: index === 0 ? '' : (React.createElement(React.Fragment, null,\n                    React.createElement(\"div\", { style: { whiteSpace: 'nowrap' } },\n                        React.createElement(\"div\", null, columnName),\n                        columnType && (React.createElement(Tag, { style: { fontSize: '10px', marginTop: '4px', color: '#5F9A97' } }, columnType))))),\n                dataIndex: header,\n                key: header,\n                ...(index === 0 && { rowScope: 'row' }),\n                ellipsis: true,\n                render: (text) => (React.createElement(\"div\", { style: {\n                        fontSize: '12px',\n                        whiteSpace: 'nowrap',\n                        overflow: 'hidden',\n                        textOverflow: 'ellipsis',\n                        maxWidth: '200px',\n                        minWidth: '25px'\n                    } }, text)),\n            };\n        }));\n    }, [htmlData]);\n    return (React.createElement(Table, { dataSource: dataSource, columns: columns, pagination: false, size: \"small\", scroll: { x: 'max-content' }, style: { fontSize: '12px', tableLayout: 'fixed', minWidth: '100%' } }));\n};\nfunction htmlToJson(htmlString) {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(htmlString, 'text/html');\n    // Extract headers from th inside thead, excluding the first one (index)\n    let headers = Array.from(doc.querySelectorAll('table thead th')).slice(1).map(th => { var _a, _b; return (_b = (_a = th.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : \"\"; });\n    const rows = doc.querySelectorAll('table tbody tr');\n    const data = Array.from(rows, row => {\n        var _a, _b;\n        const cells = row.querySelectorAll('th, td');\n        const rowObj = {};\n        // Capture the index from the first cell\n        rowObj['index'] = (_b = (_a = cells[0].textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : \"\";\n        // Map the rest of the cells to headers\n        headers.forEach((header, idx) => {\n            var _a, _b, _c;\n            rowObj[header] = (_c = (_b = (_a = cells[idx + 1]) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : \"\";\n        });\n        return rowObj;\n    });\n    return { data, headers: ['index', ...headers] }; // Set the first header to empty string\n}\nexport default DataView;\n","import React from 'react';\nimport { Tree } from 'antd';\nconst parseHTMLToJSON = (htmlContent) => {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(htmlContent, 'text/html');\n    const documentElements = doc.querySelectorAll('#documents > div._amphi_document');\n    const documents = [];\n    documentElements.forEach((element) => {\n        var _a, _b, _c;\n        const nbElement = element.querySelector('div._amphi_nb');\n        const pageContentElement = element.querySelector('div._amphi_page_content');\n        const metadataElement = element.querySelector('div._amphi_metadata');\n        if (nbElement && pageContentElement && metadataElement) {\n            const nb = ((_a = nbElement.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';\n            const pageContent = ((_b = pageContentElement.innerHTML) === null || _b === void 0 ? void 0 : _b.replace('<strong>Document Content:</strong>', '').trim()) || '';\n            let metadataText = ((_c = metadataElement.textContent) === null || _c === void 0 ? void 0 : _c.replace('Metadata:', '').trim()) || '';\n            let metadata;\n            try {\n                metadataText = metadataText.replace(/'/g, '\"'); // Replace single quotes with double quotes\n                metadata = JSON.parse(metadataText);\n            }\n            catch (e) {\n                console.error(\"Error parsing metadata:\", e);\n                metadata = metadataText; // Fall back to raw text if parsing fails\n            }\n            documents.push({ nb, page_content: pageContent, metadata: metadata });\n        }\n    });\n    return documents;\n};\nconst createTreeData = (documents) => {\n    return documents.map((doc, index) => ({\n        title: doc.nb,\n        key: `doc-${index}`,\n        children: [\n            {\n                title: (React.createElement(\"pre\", { style: { userSelect: 'text', cursor: 'text' } }, doc.page_content)),\n                key: `doc-${index}-page-content`\n            },\n            {\n                title: 'Metadata',\n                key: `doc-${index}-metadata`,\n                children: Object.entries(doc.metadata).map(([key, value]) => ({\n                    title: `${key}: ${value}`,\n                    key: `doc-${index}-metadata-${key}`\n                }))\n            }\n        ]\n    }));\n};\nconst DocumentView = ({ htmlData }) => {\n    const documents = parseHTMLToJSON(htmlData);\n    const treeData = createTreeData(documents);\n    return (React.createElement(Tree, { defaultExpandedKeys: treeData.map(node => node.key), defaultSelectedKeys: treeData.map(node => node.key), defaultCheckedKeys: treeData.map(node => node.key), treeData: treeData }));\n};\nexport default DocumentView;\n","import { Signal } from '@lumino/signaling';\nclass AbstractHandler {\n    constructor(connector) {\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this._rendermime = null;\n        this._connector = connector;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    get rendermime() {\n        return this._rendermime;\n    }\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit();\n        Signal.clearData(this);\n    }\n}\n/**\n * An object that handles code inspection.\n */\nexport class PipelineConsoleHandler extends AbstractHandler {\n    constructor(options) {\n        var _a;\n        super(options.connector);\n        this._id = options.id;\n        this._rendermime = (_a = options.rendermime) !== null && _a !== void 0 ? _a : null;\n        this._ready = this._connector.ready;\n        this._connector.kernelRestarted.connect((sender, kernelReady) => {\n            const title = {\n                contextName: '<b>Restarting kernel...</b> '\n            };\n            this._ready = this._connector.ready;\n        });\n    }\n    get id() {\n        return this._id;\n    }\n    get ready() {\n        return this._ready;\n    }\n}\n","import { LabIcon } from '@jupyterlab/ui-components';\nimport clockIconSvgStr from '../style/icons/clock-16.svg';\nimport gridIconSvgStr from '../style/icons/grid-16.svg';\nimport cpuIconSvgStr from '../style/icons/cpu-16.svg';\nimport pipelineIconSvgStr from '../style/icons/pipeline-16.svg';\nexport const clockIcon = new LabIcon({\n    name: 'amphi:clock-icon',\n    svgstr: clockIconSvgStr\n});\nexport const pipelineIcon = new LabIcon({\n    name: 'amphi:pipeline-console-icon',\n    svgstr: pipelineIconSvgStr\n});\nexport const gridIcon = new LabIcon({\n    name: 'amphi:grid-console-icon',\n    svgstr: gridIconSvgStr\n});\nexport const cpuIcon = new LabIcon({\n    name: 'amphi:cpu-icon',\n    svgstr: cpuIconSvgStr\n});\n","import { ICommandPalette, WidgetTracker } from '@jupyterlab/apputils';\nimport { ILabShell, ILayoutRestorer } from '@jupyterlab/application';\nimport { Sanitizer } from '@jupyterlab/apputils';\nimport { renderText } from '@jupyterlab/rendermime';\nimport { listIcon } from '@jupyterlab/ui-components';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { IPipelineTracker } from '@amphi/pipeline-editor';\nimport { PipelineConsoleHandler } from './handler';\nimport { KernelConnector } from './kernelconnector';\nimport { PipelineConsolePanel } from './logconsole';\nimport { LogConsoleManager } from './manager';\nimport { IPipelineConsoleManager } from './tokens';\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.open = 'pipeline-console:open';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * A service providing variable introspection.\n */\nconst logsconsole = {\n    id: '@amphi/pipeline-log-console:extension',\n    requires: [ICommandPalette, ILayoutRestorer, ILabShell, ISettingRegistry, IPipelineTracker],\n    provides: IPipelineConsoleManager,\n    autoStart: true,\n    activate: (app, palette, restorer, labShell, settings, pipelines) => {\n        const manager = new LogConsoleManager();\n        const category = 'Pipeline Console';\n        const command = CommandIDs.open;\n        const label = 'Pipeline Console';\n        const namespace = 'pipeline-console';\n        const tracker = new WidgetTracker({ namespace });\n        let maxPreview = 80;\n        function loadSetting(setting) {\n            // Read the settings and convert to the correct type\n            maxPreview = setting.get('maxPreview').composite;\n            console.log(`Settings Example extension: maxPreview is set to '${maxPreview}'`);\n        }\n        Promise.all([app.restored, settings.load('@amphi/pipeline-log-console:extension')])\n            .then(([, setting]) => {\n            // Read the settings\n            loadSetting(setting);\n            // Listen for your plugin setting changes using Signal\n            setting.changed.connect(loadSetting);\n            /**\n             * Create and track a new inspector.\n             */\n            function newPanel() {\n                // Get the current widget from the lab shell\n                const currentWidget = labShell.currentWidget;\n                // Ensure the current widget is a pipeline and has a context\n                if (!currentWidget || !pipelines.has(currentWidget)) {\n                    console.warn('No active pipeline to provide context.');\n                    return;\n                }\n                const pipelinePanel = currentWidget;\n                const context = pipelinePanel.context;\n                const panel = new PipelineConsolePanel(app, app.commands, context);\n                panel.id = 'amphi-logConsole';\n                panel.title.label = 'Pipeline Console';\n                panel.title.icon = listIcon;\n                panel.title.closable = true;\n                panel.disposed.connect(() => {\n                    if (manager.panel === panel) {\n                        manager.panel = null;\n                    }\n                });\n                // Track the inspector panel\n                tracker.add(panel);\n                return panel;\n            }\n            // Add command to palette\n            app.commands.addCommand(command, {\n                label,\n                execute: () => {\n                    const metadataPanelId = 'amphi-metadataPanel'; // Using the provided log console panel ID\n                    let metadataPanel = null;\n                    // Iterate over each widget in the 'main' area to find the log console\n                    for (const widget of app.shell.widgets('main')) {\n                        if (widget.id === metadataPanelId) {\n                            metadataPanel = widget;\n                            break;\n                        }\n                    }\n                    if (!manager.panel || manager.panel.isDisposed) {\n                        manager.panel = newPanel();\n                    }\n                    // Check if the metadata panel is found and is attached\n                    if (metadataPanel && metadataPanel.isAttached) {\n                        // If log console panel is open, add the preview panel as a tab next to it\n                        if (!manager.panel.isAttached) {\n                            app.shell.add(manager.panel, 'main', { ref: metadataPanel.id, mode: 'tab-after' });\n                        }\n                    }\n                    else {\n                        // If log console panel is not open, open the preview panel in split-bottom mode\n                        if (!manager.panel.isAttached) {\n                            app.shell.add(manager.panel, 'main', { mode: 'split-bottom' });\n                        }\n                    }\n                    app.shell.activateById(manager.panel.id);\n                }\n            });\n            palette.addItem({ command, category });\n            app.commands.addCommand('pipeline-console:clear', {\n                execute: () => {\n                    manager.panel.clearLogs();\n                },\n                label: 'Clear Console'\n            });\n            app.commands.addCommand('pipeline-console:settings', {\n                execute: () => {\n                },\n                label: 'Console Settings'\n            });\n            app.contextMenu.addItem({\n                command: 'pipeline-console:clear',\n                selector: '.amphi-Console',\n                rank: 1\n            });\n        })\n            .catch(reason => {\n            console.error(`Something went wrong when reading the settings.\\n${reason}`);\n        });\n        // Enable state restoration\n        restorer.restore(tracker, {\n            command,\n            args: () => ({}),\n            name: () => 'amphi-logConsole'\n        });\n        console.log('JupyterLab extension @amphi/pipeline-log-console is activated!');\n        return manager;\n    }\n};\n/**\n * An extension that registers pipelines for variable inspection.\n */\nconst pipelines = {\n    id: '@amphi/pipeline-log-console:pipelines',\n    requires: [IPipelineConsoleManager, IPipelineTracker, ILabShell],\n    autoStart: true,\n    activate: (app, manager, pipelines, labShell) => {\n        const handlers = {};\n        function formatLogDate(date) {\n            const dateObj = new Date(date);\n            return `${dateObj.toLocaleDateString()}\\n${dateObj.toLocaleTimeString()}`;\n        }\n        /**\n         * Subscribes to the creation of new pipelines. If a new pipeline is created, build a new handler for the pipelines.\n         * Adds a promise for a instanced handler to the 'handlers' collection.\n         */\n        pipelines.widgetAdded.connect((sender, pipelinePanel) => {\n            if (manager.hasHandler(pipelinePanel.context.sessionContext.path)) {\n                handlers[pipelinePanel.id] = new Promise((resolve, reject) => {\n                    resolve(manager.getHandler(pipelinePanel.context.sessionContext.path));\n                });\n            }\n            else {\n                handlers[pipelinePanel.id] = new Promise((resolve, reject) => {\n                    const session = pipelinePanel.context.sessionContext;\n                    // Create connector and init w script if it exists for kernel type.\n                    const connector = new KernelConnector({ session });\n                    const options = {\n                        connector: connector,\n                        id: session.path //Using the sessions path as an identifier for now.\n                    };\n                    const handler = new PipelineConsoleHandler(options);\n                    manager.addHandler(handler);\n                    pipelinePanel.disposed.connect(() => {\n                        delete handlers[pipelinePanel.id];\n                        handler.dispose();\n                    });\n                    handler.ready.then(() => {\n                        resolve(handler);\n                        connector.ready.then(async () => {\n                            session.session.kernel.anyMessage.connect((sender, args) => {\n                                if (manager.panel) {\n                                    if (args.direction === 'recv') {\n                                        // Filter and process kernel messages here\n                                        // For example, args.msg.header.msg_type might be 'stream' for log messages\n                                        if (args.msg.header.msg_type === 'execute_result' || args.msg.header.msg_type === 'display_data') {\n                                            // Assert the message type to IExecuteResultMsg or IDisplayDataMsg to access 'data'\n                                            const content = args.msg.content;\n                                            if (content.data['text/html']) {\n                                                manager.panel.onNewLog(formatLogDate(args.msg.header.date), session.name, \"data\", content.data['text/html'], content.metadata);\n                                            }\n                                        }\n                                        else if (args.msg.header.msg_type === 'stream') {\n                                            const streamMsg = args.msg;\n                                            if (streamMsg.content.text && streamMsg.content.text !== '\\n') {\n                                                // Create a container div for the content\n                                                const streamText = document.createElement('div');\n                                                console.log(\"streamMsg.content.text %o\", streamMsg.content.text);\n                                                // Directly set innerHTML with replaced newlines, avoiding renderText to prevent duplication\n                                                streamText.innerHTML = streamMsg.content.text.replace(/\\n/g, '<br>');\n                                                // Convert the entire structure to HTML string if necessary\n                                                const streamHTML = streamText.outerHTML;\n                                                manager.panel.onNewLog(formatLogDate(args.msg.header.date), session.name, \"info\", streamHTML, null);\n                                            }\n                                        }\n                                        else if (args.msg.header.msg_type === 'error') {\n                                            // Handle error messages\n                                            const errorMsg = args.msg; // If using TypeScript\n                                            const traceback = errorMsg.content.traceback.join('\\n');\n                                            const errorId = `traceback-${Date.now()}`; // Unique ID for the traceback container\n                                            // Create a container for the error message and the link\n                                            const errorContainer = document.createElement('div');\n                                            const errorMessageText = `${errorMsg.content.evalue}`;\n                                            // Ensure the link has a unique ID that matches the pattern for event delegation\n                                            // Can do better here, ... TODO\n                                            errorContainer.innerHTML = `<pre><span>${errorMessageText}</span><br><a href=\"#\" style=\"text-decoration: underline; color: grey;\" id=\"link-${errorId}\" onClick=\"document.getElementById('${errorId}').style.display = document.getElementById('${errorId}').style.display === 'none' ? 'block' : 'none'; return false;\">Show Traceback</a></pre>`;\n                                            // Create a container for the traceback, initially hidden\n                                            const tracebackContainer = document.createElement('pre');\n                                            tracebackContainer.id = errorId;\n                                            tracebackContainer.style.display = 'none';\n                                            errorContainer.appendChild(tracebackContainer);\n                                            // Use the sanitizer to safely render the traceback\n                                            const options = {\n                                                host: tracebackContainer,\n                                                source: traceback,\n                                                sanitizer: new Sanitizer(), // Use the default sanitizer\n                                            };\n                                            renderText(options).then(() => {\n                                                // Once the traceback is sanitized and rendered, append it to the errorContainer\n                                                // Convert the entire structure to HTML string if necessary\n                                                const errorHTML = errorContainer.outerHTML;\n                                                manager.panel.onNewLog(formatLogDate(errorMsg.header.date), session.name, \"error\", errorHTML, null);\n                                            });\n                                        }\n                                    }\n                                }\n                            });\n                        });\n                    });\n                });\n            }\n            setSource(labShell);\n        });\n        const setSource = (sender, args) => {\n            var _a;\n            const widget = (_a = args === null || args === void 0 ? void 0 : args.newValue) !== null && _a !== void 0 ? _a : sender.currentWidget;\n            if (!widget || !pipelines.has(widget)) {\n                return;\n            }\n            const future = handlers[widget.id];\n            future.then((source) => {\n                if (source) {\n                    manager.source = source;\n                    // manager.source.performInspection();\n                }\n            });\n        };\n        /**\n         * If focus window changes, checks whether new focus widget is a console.\n         * In that case, retrieves the handler associated to the console after it has been\n         * initialized and updates the manager with it.\n         */\n        setSource(labShell);\n        labShell.currentChanged.connect(setSource);\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [\n    logsconsole,\n    pipelines\n];\nexport default plugins;\n","import { Signal } from '@lumino/signaling';\n/**\n * Connector class that handles execute request to a kernel\n */\nexport class KernelConnector {\n    constructor(options) {\n        this._kernelRestarted = new Signal(this);\n        this._session = options.session;\n        this._session.statusChanged.connect((sender, newStatus) => {\n            switch (newStatus) {\n                case 'restarting':\n                    this._kernelRestarted.emit(this._session.ready);\n                    break;\n                case 'autorestarting':\n                    this._kernelRestarted.emit(this._session.ready);\n                    break;\n                default:\n                    break;\n            }\n        });\n    }\n    get kernelRestarted() {\n        return this._kernelRestarted;\n    }\n    get kernelLanguage() {\n        var _a;\n        if (!((_a = this._session.session) === null || _a === void 0 ? void 0 : _a.kernel)) {\n            return Promise.resolve('');\n        }\n        return this._session.session.kernel.info.then(infoReply => {\n            return infoReply.language_info.name;\n        });\n    }\n    get kernelName() {\n        return this._session.kernelDisplayName;\n    }\n    /**\n     *  A Promise that is fulfilled when the session associated w/ the connector is ready.\n     */\n    get ready() {\n        return this._session.ready;\n    }\n    /**\n     *  A signal emitted for iopub messages of the kernel associated with the kernel.\n     */\n    get iopubMessage() {\n        return this._session.iopubMessage;\n    }\n    execute(content) {\n        var _a;\n        if (!((_a = this._session.session) === null || _a === void 0 ? void 0 : _a.kernel)) {\n            throw new Error('No session available.');\n        }\n        return this._session.session.kernel.requestExecute(content);\n    }\n}\n","import { Widget } from '@lumino/widgets';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport DataView from './DataView';\nimport DocumentView from './DocumentView';\nimport { Alert, Tag, Divider } from 'antd';\nimport { clockIcon, pipelineIcon, gridIcon, cpuIcon } from './icons';\nconst TITLE_CLASS = 'amphi-Console-title';\nconst PANEL_CLASS = 'amphi-Console';\nconst TABLE_CLASS = 'amphi-Console-table';\nconst TABLE_BODY_CLASS = 'amphi-Console-content';\nconst TABLE_ROW_CLASS = 'amphi-Console-table-row';\nconst SINGLE_COLUMN_CLASS = 'amphi-Console-single-column'; // New class for single column\n/**\n * A panel that renders the pipeline logs\n */\nexport class PipelineConsolePanel extends Widget {\n    constructor(app, commands, context) {\n        super();\n        this._source = null;\n        this._app = app; // Assign the app object\n        this._commands = commands;\n        this._context = context;\n        this.addClass(PANEL_CLASS);\n        this._title = Private.createTitle();\n        this._title.className = TITLE_CLASS;\n        this._console = Private.createConsole();\n        this._console.className = TABLE_CLASS;\n        this.node.appendChild(this._title);\n        this.node.appendChild(this._console);\n    }\n    get source() {\n        return this._source;\n    }\n    set source(source) {\n        if (this._source === source) {\n            return;\n        }\n        // Remove old subscriptions\n        if (this._source) {\n            this._source.disposed.disconnect(this.onSourceDisposed, this);\n        }\n        this._source = source;\n        // Subscribe to new object\n        if (this._source) {\n            this._source.disposed.connect(this.onSourceDisposed, this);\n        }\n    }\n    /**\n     * Dispose resources\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.source = null;\n        super.dispose();\n    }\n    onNewLog(date, pipelineName, level, content, metadata) {\n        if (!this.isAttached) {\n            return;\n        }\n        // Ensure the table footer exists\n        if (!this._console.tFoot) {\n            this._console.createTFoot();\n            this._console.tFoot.className = TABLE_BODY_CLASS;\n        }\n        // Insert a new row at the beginning of the table footer\n        let row = this._console.tFoot.insertRow(0);\n        row.className = `${TABLE_ROW_CLASS} ${SINGLE_COLUMN_CLASS}`; // Add single column class\n        // Add a single cell to the new row\n        let singleCell = row.insertCell(0);\n        singleCell.style.padding = \"5px\";\n        singleCell.className = SINGLE_COLUMN_CLASS;\n        let dateTag;\n        let pipelineNameTag = React.createElement(Tag, { bordered: false, icon: React.createElement(pipelineIcon.react, { className: \"anticon amphi-Console-icon-size\" }), style: { whiteSpace: 'normal', wordWrap: 'break-word' } }, pipelineName);\n        let dataframeSizeTag = null;\n        let nodeIdTag = null;\n        let runtimeTag = null;\n        let contentComponent;\n        let viewData = null;\n        switch (level) {\n            case \"info\":\n                dateTag = React.createElement(Tag, { bordered: false, icon: React.createElement(clockIcon.react, { className: \"anticon\" }), style: { whiteSpace: 'normal', wordWrap: 'break-word' } }, date);\n                contentComponent = (React.createElement(Alert, { showIcon: true, banner: true, message: React.createElement(\"div\", { dangerouslySetInnerHTML: { __html: content } }), type: /SUCCESS/i.test(content) ? \"success\" : /ERROR|WARNING/i.test(content) ? \"warning\" : \"info\" }));\n                break;\n            case \"error\":\n                dateTag = React.createElement(Tag, { bordered: false, icon: React.createElement(clockIcon.react, { className: \"anticon amphi-Console-icon-size\" }), style: { whiteSpace: 'normal', wordWrap: 'break-word' } }, date);\n                contentComponent = (React.createElement(Alert, { message: \"Error\", banner: true, showIcon: true, description: React.createElement(\"div\", { dangerouslySetInnerHTML: { __html: content.replace(/\\n/g, '<br>').replace(/\\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;') } }), type: \"error\" }));\n                break;\n            case \"data\":\n                dateTag = React.createElement(Tag, { bordered: false, icon: React.createElement(clockIcon.react, { className: \"anticon amphi-Console-icon-size\" }), style: { whiteSpace: 'normal', wordWrap: 'break-word' } }, date);\n                nodeIdTag = React.createElement(Tag, { bordered: false, icon: React.createElement(clockIcon.react, { className: \"anticon amphi-Console-icon-size\" }), style: { whiteSpace: 'normal', wordWrap: 'break-word' } }, metadata.nodeId);\n                runtimeTag = React.createElement(Tag, { bordered: false, icon: React.createElement(cpuIcon.react, { className: \"anticon amphi-Console-icon-size\" }), style: { whiteSpace: 'normal', wordWrap: 'break-word' } }, metadata.runtime);\n                viewData = (React.createElement(Tag, { bordered: false, onClick: () => this._commands.execute('pipeline-editor-component:view-data', { nodeId: metadata.nodeId, context: this._context }), icon: React.createElement(clockIcon.react, { className: \"anticon amphi-Console-icon-size\" }), color: \"#44776D\", style: { whiteSpace: 'normal', wordWrap: 'break-word' } }, \"View data\"));\n                const parser = new DOMParser();\n                const doc = parser.parseFromString(content, 'text/html');\n                const firstDiv = doc.querySelector('div');\n                if (firstDiv && firstDiv.id === 'documents') {\n                    contentComponent = React.createElement(DocumentView, { htmlData: content });\n                }\n                else {\n                    // Extract dataframe size from the last paragraph if it exists\n                    const sizeElement = doc.querySelector('p:last-of-type');\n                    let dataframeSize = null;\n                    if (sizeElement && sizeElement.textContent.includes('rows Ã—')) {\n                        dataframeSize = sizeElement.textContent.trim();\n                    }\n                    if (dataframeSize) {\n                        dataframeSizeTag = React.createElement(Tag, { bordered: false, icon: React.createElement(gridIcon.react, { className: \"anticon amphi-Console-icon-size\" }), style: { whiteSpace: 'normal', wordWrap: 'break-word' } }, dataframeSize);\n                    }\n                    contentComponent = (React.createElement(React.Fragment, null,\n                        React.createElement(DataView, { htmlData: content })));\n                }\n                break;\n            default:\n                dateTag = React.createElement(Tag, { bordered: false }, date);\n                contentComponent = React.createElement(\"div\", null, content);\n        }\n        // Render tags and content inside the single cell\n        ReactDOM.render(React.createElement(\"div\", { style: { display: 'flex', flexDirection: 'column', gap: '4px' } },\n            React.createElement(\"div\", { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: '0px', marginBottom: '2px' } },\n                React.createElement(\"div\", { style: { display: 'flex', alignItems: 'center', gap: '4px' } },\n                    dateTag,\n                    pipelineNameTag,\n                    dataframeSizeTag,\n                    runtimeTag),\n                React.createElement(\"div\", null)),\n            React.createElement(\"div\", null, contentComponent),\n            React.createElement(Divider, { style: { margin: '6px 0' } })), singleCell);\n        // Scroll to the top\n        this._console.parentElement.scrollTop = 0;\n    }\n    clearLogs() {\n        // Check if table footer exists and remove all its rows\n        if (this._console.tFoot) {\n            while (this._console.tFoot.rows.length > 0) {\n                this._console.tFoot.deleteRow(0);\n            }\n        }\n    }\n    /**\n     * Handle source disposed signals.\n     */\n    onSourceDisposed(sender, args) {\n        this.source = null;\n    }\n}\nvar Private;\n(function (Private) {\n    const entityMap = new Map(Object.entries({\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;',\n        '/': '&#x2F;'\n    }));\n    function escapeHtml(source) {\n        return String(source).replace(/[&<>\"'/]/g, (s) => entityMap.get(s));\n    }\n    Private.escapeHtml = escapeHtml;\n    function createConsole() {\n        const table = document.createElement('table');\n        return table;\n    }\n    Private.createConsole = createConsole;\n    function createTitle(header = '') {\n        const title = document.createElement('p');\n        title.innerHTML = header;\n        return title;\n    }\n    Private.createTitle = createTitle;\n})(Private || (Private = {}));\n","/**\n * A class that manages variable inspector widget instances and offers persistent\n * `IMetadataPanel` instance that other plugins can communicate with.\n */\nexport class LogConsoleManager {\n    constructor() {\n        this._source = null;\n        this._panel = null;\n        this._handlers = {};\n    }\n    hasHandler(id) {\n        if (this._handlers[id]) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    getHandler(id) {\n        return this._handlers[id];\n    }\n    addHandler(handler) {\n        this._handlers[handler.id] = handler;\n    }\n    /**\n     * The current console panel.\n     */\n    get panel() {\n        return this._panel;\n    }\n    set panel(panel) {\n        if (this.panel === panel) {\n            return;\n        }\n        this._panel = panel;\n        if (panel && !panel.source) {\n            panel.source = this._source;\n        }\n    }\n    /**\n     * The source of events the inspector panel listens for.\n     */\n    get source() {\n        return this._source;\n    }\n    set source(source) {\n        if (this._source === source) {\n            return;\n        }\n        // remove subscriptions\n        if (this._source) {\n            this._source.disposed.disconnect(this._onSourceDisposed, this);\n        }\n        this._source = source;\n        if (this._panel && !this._panel.isDisposed) {\n            this._panel.source = this._source;\n        }\n        // Subscribe to new source\n        if (this._source) {\n            this._source.disposed.connect(this._onSourceDisposed, this);\n        }\n    }\n    _onSourceDisposed() {\n        this._source = null;\n    }\n}\n","import { Token } from '@lumino/coreutils';\nexport const IPipelineConsoleManager = new Token('jupyterlab_extension/logconsole:IPipelineConsoleManager');\n/**\n * The inspector panel token.\n */\nexport const IPipelineConsole = new Token('jupyterlab_extension/logconsole:IPipelineConsole');\n"],"names":[],"sourceRoot":""}