"""
This type stub file was generated by cyright.
"""

import cython
from dearcygui.wrapper import *
from dearcygui.backends.backend import *
from typing import Any
from enum import IntEnum

C: Context = ...
class Context:
    """
    Main class managing the DearCyGui items and imgui context.
    There is exactly one viewport per context.

    Items are assigned an uuid and eventually a user tag.
    indexing the context with the uuid or the tag returns
    the object associated.

    The last created context can be accessed as deacygui.C
    """
    def __init__(self, queue=...) -> None:
        """
        Parameters:
            queue (optional, defaults to ThreadPoolExecutor(max_workers=1)):
                Subclass of concurrent.futures.Executor used to submit
                callbacks during the frame.
        """
        ...
    
    def __del__(self): # -> None:
        ...
    
    @property
    def viewport(self) -> Viewport:
        """Readonly attribute: root item from where rendering starts"""
        ...
    
    def __getitem__(self, key): # -> baseItem | SharedValue:
        """
        Retrieves the object associated to
        a tag or an uuid
        """
        ...
    
    def push_next_parent(self, next_parent: baseItem) -> Any:
        """
        Each time 'with' is used on an item, it is pushed
        to the list of potentialy parents to use if
        no parent (or before) is set when an item is created.
        If the list is empty, items are left unattached and
        can be attached later.

        In order to enable multiple threads from using
        the 'with' syntax, thread local storage is used,
        such that each thread has its own list.
        """
        ...
    
    def pop_next_parent(self) -> Any:
        """
        Remove an item from the potential parent list.
        """
        ...
    
    def fetch_parent_queue_back(self) -> object:
        """
        Retrieve the last item from the potential parent list
        """
        ...
    
    def fetch_parent_queue_front(self) -> object:
        """
        Retrieve the top item from the potential parent list
        """
        ...
    
    def fetch_last_created_item(self) -> object:
        """
        Return the last item created in this thread.
        Returns None if the last item created has been
        deleted.
        """
        ...
    
    def fetch_last_created_container(self) -> object:
        """
        Return the last item which can have children
        created in this thread.
        Returns None if the last such item has been
        deleted.
        """
        ...
    
    def is_key_down(self, key: int, keymod: int = ...): # -> bint | Literal[False]:
        """
        Is key being held.

        key is a key constant (see constants)
        keymod is a mask if keymod constants (ctrl, shift, alt, super)
        if keymod is negative, ignores any key modifiers.
        If non-negative, returns True only if the modifiers
        correspond as well as the key.
        """
        ...
    
    def is_key_pressed(self, key: int, keymod: int = ..., repeat: bool = ...): # -> bint | Literal[False]:
        """
        Was key pressed (went from !Down to Down)?
        
        if repeat=true, the pressed state is repeated
        if the user continue pressing the key.
        If keymod is non-negative, returns True only if the modifiers
        correspond as well as the key.

        """
        ...
    
    def is_key_released(self, key: int, keymod: int = ...): # -> bint | Literal[True]:
        """
        Was key released (went from Down to !Down)?
        
        If keymod is non-negative, returns True also if the
        required modifiers are not pressed.
        """
        ...
    
    def is_mouse_down(self, button: int): # -> bint:
        """is mouse button held?"""
        ...
    
    def is_mouse_clicked(self, button: int, repeat: bool = ...): # -> bint:
        """did mouse button clicked? (went from !Down to Down). Same as get_mouse_clicked_count() >= 1."""
        ...
    
    def is_mouse_double_clicked(self, button: int): # -> bint:
        """did mouse button double-clicked?. Same as get_mouse_clicked_count() == 2."""
        ...
    
    def get_mouse_clicked_count(self, button: int): # -> int:
        """how many times a mouse button is clicked in a row"""
        ...
    
    def is_mouse_released(self, button: int): # -> bint:
        """did mouse button released? (went from Down to !Down)"""
        ...
    
    def get_mouse_position(self): # -> tuple[float, float]:
        """Retrieves the mouse position (x, y). Raises KeyError if there is no mouse"""
        ...
    
    def is_mouse_dragging(self, button: int, lock_threshold: float = ...): # -> bint:
        """is mouse dragging? (uses default distance threshold if lock_threshold < 0.0f"""
        ...
    
    def get_mouse_drag_delta(self, button: int, lock_threshold: float = ...): # -> tuple[float, float]:
        """
        Return the delta (dx, dy) from the initial clicking position while the mouse button is pressed or was just released.
        
        This is locked and return 0.0f until the mouse moves past a distance threshold at least once
        (uses default distance if lock_threshold < 0.0f)"""
        ...
    
    def reset_mouse_drag_delta(self, button: int): # -> void:
        """Reset to 0 the drag delta for the target button"""
        ...
    
    @property
    def running(self): # -> bint:
        ...
    
    @running.setter
    def running(self, value: bool): # -> None:
        ...
    
    @property
    def clipboard(self): # -> str:
        """Writable attribute: content of the clipboard"""
        ...
    
    @clipboard.setter
    def clipboard(self, value: str): # -> None:
        ...
    


class baseItem:
    """
    Base class for all items (except shared values)

    To be rendered, an item must be in the child tree
    of the viewport (context.viewport).

    The parent of an item can be set with various ways:
    1) Using the parent attribute. item.parent = target_item
    2) Passing (parent=target_item) during item creation
    3) If the context manager is not empty ('with' on an item),
       and no parent is set (parent = None passed or nothing),
       the last item in 'with' is taken as parent. The context
       manager can be managed directly with context.push_next_parent()
       and context.pop_next_parent()
    4) if you set the previous_sibling or next_sibling attribute,
       the item will be inserted respectively after and before the
       respective items in the parent item children list. For legacy
       support, the 'before=target_item' attribute can be used during item creation,
       and is equivalent to item.next_sibling = target_item

    parent, previous_sibling and next_sibling are baseItem attributes
    and can be read at any time.
    It is possible to get the list of children of an item as well
    with the 'children' attribute: item.children.

    For ease of use, the items can be named for easy retrieval.
    The tag attribute is a user string that can be set at any
    moment and can be passed for parent/previous_sibling/next_sibling.
    The item associated with a tag can be retrieved with context[tag].
    Note that having a tag doesn't mean the item is referenced by the context.
    If an item is not in the subtree of the viewport, and is not referenced,
    it might get deleted.

    During rendering the children of each item are rendered in
    order from the first one to the last one.
    When an item is attached to a parent, it is by default inserted
    last, unless previous_sibling or next_sibling is used.

    previous_sibling and next_sibling enable to insert an item
    between elements.

    When parent, previous_sibling or next_sibling are set, the item
    is detached from any parent or sibling it had previously.

    An item can be manually detached from a parent
    by setting parent = None.

    Most items have restrictions for the parents and children it can
    have. In addition some items can have several children lists
    of incompatible types. These children list will be concatenated
    when reading item.children. In a given list are items of a similar
    type.

    Finally some items cannot be children of any item in the rendering
    tree. One such item is PlaceHolderParent, which can be parent
    of any item which can have a parent. PlaceHolderParent cannot
    be inserted in the rendering tree, but can be used to store items
    before their insertion in the rendering tree.
    Other such items are textures, themes, colormaps and fonts. Those
    items cannot be made children of items of the rendering tree, but
    can be bound to them. For example item.theme = theme_item will
    bind theme_item to item. It is possible to bind such an item to
    several items, and as long as one item reference them, they will
    not be deleted by the garbage collector.
    """
    def __init__(self, context, *args, **kwargs) -> None:
        ...
    
    def configure(self, **kwargs): # -> None:
        ...
    
    @property
    def context(self): # -> Context:
        """
        Read-only attribute: Context in which the item resides
        """
        ...
    
    @property
    def user_data(self): # -> object:
        """
        User data of any type.
        """
        ...
    
    @user_data.setter
    def user_data(self, value): # -> None:
        ...
    
    @property
    def uuid(self): # -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        """
        ...
    
    @property
    def tag(self): # -> baseItem:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        """
        ...
    
    @tag.setter
    def tag(self, tag: str): # -> None:
        ...
    
    @property
    def parent(self): # -> baseItem:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        """
        ...
    
    @parent.setter
    def parent(self, value): # -> None:
        ...
    
    @property
    def previous_sibling(self): # -> baseItem:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        """
        ...
    
    @previous_sibling.setter
    def previous_sibling(self, target: baseItem): # -> None:
        ...
    
    @property
    def next_sibling(self): # -> baseItem:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        """
        ...
    
    @next_sibling.setter
    def next_sibling(self, target: baseItem): # -> None:
        ...
    
    @property
    def children(self): # -> list:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        """
        ...
    
    @children.setter
    def children(self, value): # -> None:
        ...
    
    def __enter__(self): # -> Self@baseItem:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> Literal[False]:
        ...
    
    def attach_to_parent(self, target) -> Any:
        """
        Same as item.parent = target, but
        target must not be None
        """
        ...
    
    def attach_before(self, target) -> Any:
        """
        Same as item.next_sibling = target,
        but target must not be None
        """
        ...
    
    def detach_item(self) -> Any:
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        """
        ...
    
    def delete_item(self) -> Any:
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        """
        ...
    
    def lock_mutex(self, wait=...): # -> bool:
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        """
        ...
    
    def unlock_mutex(self): # -> bool:
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        """
        ...
    
    @property
    def mutex(self): # -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        """
        ...
    
    @property
    def parents_mutex(self): # -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        """
        ...
    


class wrap_mutex:
    def __init__(self, target) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> Literal[False]:
        ...
    


class wrap_this_and_parents_mutex:
    def __init__(self, target) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> Literal[False]:
        ...
    


@cython.final
@cython.no_gc_clear
class Viewport(baseItem):
    """
    The viewport corresponds to the main item containing
    all the visuals. It is decorated by the operating system,
    and can be minimized/maximized/made fullscreen.

    Rendering starts from the viewports and recursively
    every item renders itself and its children.
    """
    def initialize(self, minimized=..., maximized=..., **kwargs): # -> None:
        """
        Initialize the viewport for rendering and show it.
        Items can already be created and attached to the viewport
        before this call.
        Creates the default font and attaches it to the viewport
        if None is set already. This font is scaled by
        the current value of viewport.dpi.
        In addition all the default style spaces are scaled by
        the current viewport.dpi.
        The viewport.dpi content is not read after that, and
        so changes will have no effect.
        """
        ...
    
    @property
    def clear_color(self): # -> tuple:
        ...
    
    @clear_color.setter
    def clear_color(self, value): # -> None:
        ...
    
    @property
    def small_icon(self): # -> str:
        ...
    
    @small_icon.setter
    def small_icon(self, value: str): # -> None:
        ...
    
    @property
    def large_icon(self): # -> str:
        ...
    
    @large_icon.setter
    def large_icon(self, value: str): # -> None:
        ...
    
    @property
    def x_pos(self):
        ...
    
    @x_pos.setter
    def x_pos(self, value: int): # -> None:
        ...
    
    @property
    def y_pos(self):
        ...
    
    @y_pos.setter
    def y_pos(self, value: int): # -> None:
        ...
    
    @property
    def width(self):
        ...
    
    @width.setter
    def width(self, value: int): # -> None:
        ...
    
    @property
    def height(self):
        ...
    
    @height.setter
    def height(self, value: int): # -> None:
        ...
    
    @property
    def resizable(self) -> bool:
        ...
    
    @resizable.setter
    def resizable(self, value: bool): # -> None:
        ...
    
    @property
    def vsync(self) -> bool:
        ...
    
    @vsync.setter
    def vsync(self, value: bool): # -> None:
        ...
    
    @property
    def dpi(self) -> float:
        """
        Requested scaling (DPI) from the OS for
        this window. The value is valid after
        initialize() and might change over time,
        for instance if the window is moved to another
        monitor.

        The DPI is used to scale all items automatically.
        From the developper point of view, everything behaves
        as if the DPI is 1. This behaviour can be disabled
        using the related scaling settings.
        """
        ...
    
    @property
    def scale(self) -> float:
        """
        Multiplicative scale that, multiplied by
        the value of dpi, is used to scale
        automatically all items.

        Defaults to 1.
        """
        ...
    
    @scale.setter
    def scale(self, value: float): # -> None:
        ...
    
    @property
    def min_width(self):
        ...
    
    @min_width.setter
    def min_width(self, value: int): # -> None:
        ...
    
    @property
    def max_width(self):
        ...
    
    @max_width.setter
    def max_width(self, value: int): # -> None:
        ...
    
    @property
    def min_height(self):
        ...
    
    @min_height.setter
    def min_height(self, value: int): # -> None:
        ...
    
    @property
    def max_height(self):
        ...
    
    @max_height.setter
    def max_height(self, value: int): # -> None:
        ...
    
    @property
    def always_on_top(self) -> bool:
        ...
    
    @always_on_top.setter
    def always_on_top(self, value: bool): # -> None:
        ...
    
    @property
    def decorated(self) -> bool:
        ...
    
    @decorated.setter
    def decorated(self, value: bool): # -> None:
        ...
    
    @property
    def handlers(self): # -> list:
        """
        Writable attribute: bound handler (or handlerList)
        for the viewport.
        Only Key and Mouse handlers are compatible.
        Handlers that check item states won't work.
        """
        ...
    
    @handlers.setter
    def handlers(self, value): # -> None:
        ...
    
    @property
    def cursor(self): # -> mouse_cursor:
        """
        Change the mouse cursor to one of mouse_cursor.
        The mouse cursor is reset every frame.
        """
        ...
    
    @cursor.setter
    def cursor(self, value: int): # -> None:
        ...
    
    @property
    def font(self):
        """
        Writable attribute: global font
        """
        ...
    
    @font.setter
    def font(self, value: Font): # -> None:
        ...
    
    @property
    def theme(self):
        """
        Writable attribute: global theme
        """
        ...
    
    @theme.setter
    def theme(self, value: baseTheme): # -> None:
        ...
    
    @property
    def title(self): # -> str:
        ...
    
    @title.setter
    def title(self, value: str): # -> None:
        ...
    
    @property
    def disable_close(self) -> bool:
        ...
    
    @disable_close.setter
    def disable_close(self, value: bool): # -> None:
        ...
    
    @property
    def fullscreen(self):
        ...
    
    @fullscreen.setter
    def fullscreen(self, value: bool): # -> None:
        ...
    
    @property
    def minimized(self): # -> None:
        ...
    
    @minimized.setter
    def minimized(self, value: bool): # -> None:
        ...
    
    @property
    def maximized(self): # -> None:
        ...
    
    @maximized.setter
    def maximized(self, value: bool): # -> None:
        ...
    
    @property
    def wait_for_input(self):
        """
        Writable attribute: When the app doesn't need to be
        refreshed, one can save power comsumption by not
        rendering. wait_for_input will pause rendering until
        a mouse or keyboard event is received.
        wake() can also be used to restart rendering
        for one frame.
        """
        ...
    
    @wait_for_input.setter
    def wait_for_input(self, value: bool): # -> None:
        ...
    
    @property
    def shown(self) -> bool:
        """
        Whether the viewport window has been created by the
        operating system.
        """
        ...
    
    @property
    def resize_callback(self): # -> Callback:
        """
        Callback to be issued when the viewport is resized.
        """
        ...
    
    @resize_callback.setter
    def resize_callback(self, value): # -> None:
        ...
    
    @property
    def close_callback(self): # -> Callback:
        """
        Callback to be issued when the viewport is closed.
        """
        ...
    
    @close_callback.setter
    def close_callback(self, value): # -> None:
        ...
    
    @property
    def metrics(self): # -> dict[str, Any]:
        ...
    
    def configure(self, **kwargs): # -> None:
        ...
    
    def render_frame(self, can_skip_presenting: bool = ...): # -> bint:
        """
        Render one frame.

        Rendering occurs in several separated steps:
        . Mouse/Keyboard events are processed. it's there
          that wait_for_input has an effect.
        . The viewport item, and then all the rendering tree are
          walked through to query their state and prepare the rendering
          commands using ImGui, ImPlot and ImNodes
        . The rendering commands are submitted to the GPU.
        . The submission is passed to the operating system to handle the
          window update. It's usually at this step that the system will
          apply vsync by making the application wait if it rendered faster
          than the screen refresh rate.

        can_skip_presenting: rendering will occur (handlers checked, etc),
            but the backend might decide, if this flag is set, to not
            submit the rendering commands to the GPU and refresh the
            window. Can be used to avoid using the GPU in response
            to a simple mouse motion.
            Fast checks are used to determine if presenting should occur
            or not. Thus set this only if you haven't updated any content
            on the screen.
            Note wake() will automatically force a redraw the next frame.

        Returns True if the frame was presented to the screen,
            False else (can_skip_presenting)
        """
        ...
    
    def wake(self): # -> None:
        """
        In case rendering is waiting for an input (waitForInputs),
        generate a fake input to force rendering.

        This is useful if you have updated the content asynchronously
        and want to show the update
        """
        ...
    


class Callback:
    """
    Wrapper class that automatically encapsulate
    callbacks.

    Callbacks in DCG mode can take up to 3 arguments:
    . source_item: the item to which the callback was attached
    . target_item: the item for which the callback was raised.
        Is only different to source_item for handlers' callback.
    . call_info: If applicable information about the call (key button, etc)
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __call__(self, source_item, target_item, call_info): # -> None:
        ...
    


class DPGCallback(Callback):
    """
    Used to run callbacks created for DPG
    """
    def __call__(self, source_item, target_item, call_info): # -> None:
        ...
    


class PlaceHolderParent(baseItem):
    ...


class drawingItem(baseItem):
    """
    A simple item with no UI state,
    that inherit from the drawing area of its
    parent
    """
    @property
    def show(self): # -> bint:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        """
        ...
    
    @show.setter
    def show(self, value: bool): # -> None:
        ...
    


class DrawingList(drawingItem):
    """
    A simple drawing item that renders its children.
    Useful to arrange your items and quickly
    hide/show/delete them by manipulating the list.
    """
    ...


class DrawingListScale(drawingItem):
    """
    Similar to a DrawingList, but
    can apply shift and scale to the data
    """
    @property
    def scales(self): # -> double[]:
        """
        Scales applied to the x and y axes
        Default is (1., 1.).
        The scales multiply any previous scales
        already set (including plot scales).
        Use no_parent_scale to remove that behaviour.
        """
        ...
    
    @scales.setter
    def scales(self, values): # -> None:
        ...
    
    @property
    def shifts(self): # -> double[]:
        """
        Shifts applied to the x and y axes.
        Default is (0., 0.)
        The shifts are applied any previous
        shift and scale.
        For instance on x, the transformation to
        screen space is:
        parent_x_transform(x * scales[0] + shifts[0])
        """
        ...
    
    @shifts.setter
    def shifts(self, values): # -> None:
        ...
    
    @property
    def no_parent_scale(self): # -> bint:
        """
        Resets any previous scaling to screen space.
        shifts are transformed to screen space using
        the parent transform and serves as origin (0, 0)
        for the child coordinates.
        """
        ...
    
    @no_parent_scale.setter
    def no_parent_scale(self, value: bool): # -> None:
        ...
    


class DrawArrow_(drawingItem):
    ...


class DrawBezierCubic_(drawingItem):
    ...


class DrawBezierQuadratic_(drawingItem):
    ...


class DrawCircle_(drawingItem):
    ...


class DrawEllipse_(drawingItem):
    ...


class DrawImage_(drawingItem):
    ...


class DrawImageQuad_(drawingItem):
    ...


class DrawLine_(drawingItem):
    ...


class DrawPolyline_(drawingItem):
    ...


class DrawPolygon_(drawingItem):
    ...


class DrawQuad_(drawingItem):
    ...


class DrawRect_(drawingItem):
    ...


class DrawText_(drawingItem):
    ...


class DrawTriangle_(drawingItem):
    ...


class DrawInvisibleButton(drawingItem):
    """
    Invisible rectangular area, parallel to axes, behaving
    like a button (using imgui default handling of buttons).

    Unlike other Draw items, this item accepts handlers and callbacks.

    DrawInvisibleButton can be overlapped on top of each other. In that
    case only one will be considered hovered. This one corresponds to the
    last one of the rendering tree that is hovered. If the button is
    considered active (see below), it retains the hover status to itself.
    Thus if you drag an invisible button on top of items later in the
    rendering tree, they will not be considered hovered.

    Note that only the mouse button(s) that trigger activation will
    have the above described behaviour for hover tests. If the mouse
    doesn't hover anymore the item, it will remain active as long
    as the configured buttons are pressed.

    When inside a plot, drag deltas are returned in plot coordinates,
    that is the deltas correspond to the deltas you must apply
    to your drawing coordinates compared to their original position
    to apply the dragging. When not in a plot, the drag deltas are
    in screen coordinates, and you must convert yourself to drawing
    coordinates if you are applying matrix transforms to your data.
    Generally matrix transforms are not well supported by
    DrawInvisibleButtons, and the shifted position that is updated
    during dragging might be invalid.

    Dragging handlers will not be triggered if the item is not active
    (unlike normal imgui items).

    If you create a DrawInvisibleButton in front of the mouse while
    the mouse is clicked with one of the activation buttons, it will
    steal hovering and activation tests. This is not the case of other
    gui items (except modal windows).

    If your Draw Button is not part of a window (ViewportDrawList),
    the hovering test might not be reliable (except specific case above).

    DrawInvisibleButton accepts children. In that case, the children
    are drawn relative to the coordinates of the DrawInvisibleButton,
    where top left is (0, 0) and bottom right is (1, 1).
    """
    @property
    def button(self): # -> int:
        """
        Mouse button mask that makes the invisible button
        active and triggers the item's callback.

        Default is left-click.

        The mask is an (OR) combination of
        1: left button
        2: right button
        4: middle button
        """
        ...
    
    @button.setter
    def button(self, value: int): # -> None:
        ...
    
    @property
    def p1(self): # -> list:
        """
        Corner of the invisible button in plot/drawing
        space
        """
        ...
    
    @p1.setter
    def p1(self, value): # -> None:
        ...
    
    @property
    def p2(self): # -> list:
        """
        Opposite corner of the invisible button in plot/drawing
        space
        """
        ...
    
    @p2.setter
    def p2(self, value): # -> None:
        ...
    
    @property
    def min_side(self): # -> float:
        """
        If the rectangle width or height after
        coordinate transform is lower than this,
        resize the screen space transformed coordinates
        such that the width/height are at least min_side.
        Retains original ratio.
        """
        ...
    
    @min_side.setter
    def min_side(self, value: int): # -> None:
        ...
    
    @property
    def max_side(self): # -> float:
        """
        If the rectangle width or height after
        coordinate transform is higher than this,
        resize the screen space transformed coordinates
        such that the width/height are at max max_side.
        Retains original ratio.
        """
        ...
    
    @max_side.setter
    def max_side(self, value: int): # -> None:
        ...
    
    @property
    def handlers(self): # -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        """
        ...
    
    @handlers.setter
    def handlers(self, value): # -> None:
        ...
    
    @property
    def activated(self): # -> bint | bool:
        """
        Readonly attribute: has the button just been pressed
        """
        ...
    
    @property
    def active(self): # -> bint:
        """
        Readonly attribute: is the button held
        """
        ...
    
    @property
    def clicked(self): # -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def double_clicked(self): # -> bint[]:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def deactivated(self): # -> bint | bool:
        """
        Readonly attribute: has the button just been unpressed
        """
        ...
    
    @property
    def hovered(self): # -> bint:
        """
        Readonly attribute: Is the mouse inside area
        """
        ...
    
    @property
    def pos_to_viewport(self): # -> object:
        """
        Readonly attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.
        """
        ...
    
    @property
    def pos_to_window(self): # -> object:
        """
        Readonly attribute:
        Relative position to the window's starting inner
        content area.
        """
        ...
    
    @property
    def pos_to_parent(self): # -> object:
        """
        Readonly attribute:
        Relative position to latest non-drawing parent
        """
        ...
    
    @property
    def rect_size(self): # -> object:
        """
        Readonly attribute: actual (width, height) of the item on screen
        """
        ...
    
    @property
    def resized(self): # -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def no_input(self): # -> bint:
        """
        Writable attribute: If enabled, this item will not
        detect hovering or activation, thus letting other
        items taking the inputs.

        This is useful to use no_input - rather than show=False,
        if you want to still have handlers run if the item
        is in the visible region.
        """
        ...
    
    @no_input.setter
    def no_input(self, value: bool): # -> None:
        ...
    
    @property
    def capture_mouse(self): # -> bint:
        """
        Writable attribute: If set, the item will
        capture the mouse if hovered even if another
        item was already active.

        As it is not in general a good behaviour (and
        will not behave well if several items with this
        state are overlapping),
        this is reset to False every frame.

        Default is True on creation. Thus creating an item
        in front of the mouse will capture it.
        """
        ...
    
    @capture_mouse.setter
    def capture_mouse(self, value: bool): # -> None:
        ...
    


class DrawInWindow(uiItem):
    """
    An UI item that contains a region for Draw* elements.
    Enables to insert Draw* Elements inside a window.

    Inside a DrawInWindow elements, the (0, 0) coordinate
    starts at the top left of the DrawWindow and y increases
    when going down.
    The drawing region is clipped by the available width/height
    of the item (set manually, or deduced).

    An invisible button is created to span the entire drawing
    area, which is used to retrieve button states on the area
    (hovering, active, etc). If set, the callback is called when
    the mouse is pressed inside the area with any of the left,
    middle or right button.
    In addition, the use of an invisible button enables the drag
    and drop behaviour proposed by imgui.

    If you intend on dragging elements inside the drawing area,
    you can either implement yourself a hovering test for your
    specific items and use the context's is_mouse_dragging, or
    add invisible buttons on top of the elements you want to
    interact with, and combine the active and mouse dragging
    handlers. Note if you intend to make an element draggable
    that way, you must not make the element source of a Drag
    and Drop, as it impacts the hovering tests.

    Note that Drawing items do not have any hovering/clicked/
    visible/etc tests maintained and thus do not have a callback.
    """
    ...


class ViewportDrawList_(baseItem):
    ...


class KeyDownHandler_(baseHandler):
    ...


class KeyPressHandler_(baseHandler):
    ...


class KeyReleaseHandler_(baseHandler):
    ...


class MouseClickHandler_(baseHandler):
    ...


class MouseDoubleClickHandler_(baseHandler):
    ...


class MouseDownHandler_(baseHandler):
    ...


class MouseDragHandler_(baseHandler):
    ...


class MouseMoveHandler(baseHandler):
    ...


class MouseReleaseHandler_(baseHandler):
    ...


class MouseWheelHandler(baseHandler):
    @property
    def horizontal(self): # -> bint:
        """
        Whether to look at the horizontal wheel
        instead of the vertical wheel.

        NOTE: Shift+ vertical wheel => horizontal wheel
        """
        ...
    
    @horizontal.setter
    def horizontal(self, value: bool): # -> None:
        ...
    


class SharedValue:
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @property
    def value(self): # -> None:
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    @property
    def shareable_value(self): # -> Self@SharedValue:
        ...
    
    @property
    def last_frame_update(self): # -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        """
        ...
    
    @property
    def last_frame_change(self): # -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        """
        ...
    
    @property
    def num_attached(self): # -> int:
        """
        Readable attribute: Number of items sharing this value
        """
        ...
    


class SharedBool(SharedValue):
    def __init__(self, context: Context, value: bool) -> None:
        ...
    
    @property
    def value(self): # -> bint:
        ...
    
    @value.setter
    def value(self, value: bool): # -> None:
        ...
    


class SharedFloat(SharedValue):
    def __init__(self, context: Context, value: float) -> None:
        ...
    
    @property
    def value(self): # -> float:
        ...
    
    @value.setter
    def value(self, value: float): # -> None:
        ...
    


class SharedInt(SharedValue):
    def __init__(self, context: Context, value: int) -> None:
        ...
    
    @property
    def value(self): # -> int:
        ...
    
    @value.setter
    def value(self, value: int): # -> None:
        ...
    


class SharedColor(SharedValue):
    def __init__(self, context: Context, value) -> None:
        ...
    
    @property
    def value(self): # -> int:
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    


class SharedDouble(SharedValue):
    def __init__(self, context: Context, value: float) -> None:
        ...
    
    @property
    def value(self): # -> double:
        ...
    
    @value.setter
    def value(self, value: float): # -> None:
        ...
    


class SharedStr(SharedValue):
    def __init__(self, context: Context, value: str) -> None:
        ...
    
    @property
    def value(self): # -> str:
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    


class SharedFloat4(SharedValue):
    def __init__(self, context: Context, value) -> None:
        ...
    
    @property
    def value(self): # -> list:
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    


class SharedInt4(SharedValue):
    def __init__(self, context: Context, value) -> None:
        ...
    
    @property
    def value(self): # -> list:
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    


class SharedDouble4(SharedValue):
    def __init__(self, context: Context, value) -> None:
        ...
    
    @property
    def value(self): # -> list:
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    


class SharedFloatVect(SharedValue):
    def __init__(self, context: Context, value) -> None:
        ...
    
    @property
    def value(self): # -> None:
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    


class baseHandler(baseItem):
    @property
    def enabled(self): # -> bint:
        ...
    
    @enabled.setter
    def enabled(self, value: bool): # -> None:
        ...
    
    @property
    def show(self): # -> bint:
        ...
    
    @show.setter
    def show(self, value: bool): # -> None:
        ...
    
    @property
    def callback(self): # -> Callback:
        ...
    
    @callback.setter
    def callback(self, value): # -> None:
        ...
    


class uiItem(baseItem):
    def configure(self, **kwargs): # -> None:
        ...
    
    def __dir__(self): # -> list:
        ...
    
    @property
    def active(self): # -> bint:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        """
        ...
    
    @property
    def activated(self): # -> bint | bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def clicked(self): # -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def double_clicked(self): # -> bint[]:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def deactivated(self): # -> bint | Literal[False]:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def deactivated_after_edited(self): # -> bint:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def edited(self): # -> bint:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def focused(self): # -> bint:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        """
        ...
    
    @focused.setter
    def focused(self, value: bool): # -> None:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        """
        ...
    
    @property
    def hovered(self): # -> bint:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        """
        ...
    
    @property
    def resized(self): # -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def toggled(self): # -> bint | bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def visible(self): # -> bint:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        """
        ...
    
    @property
    def callbacks(self): # -> list:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        """
        ...
    
    @callbacks.setter
    def callbacks(self, value): # -> None:
        ...
    
    @property
    def enabled(self): # -> bint:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        """
        ...
    
    @enabled.setter
    def enabled(self, value: bool): # -> None:
        ...
    
    @property
    def font(self): # -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        """
        ...
    
    @font.setter
    def font(self, value: Font): # -> None:
        ...
    
    @property
    def label(self): # -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        """
        ...
    
    @label.setter
    def label(self, value: str): # -> None:
        ...
    
    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    @property
    def shareable_value(self): # -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        """
        ...
    
    @shareable_value.setter
    def shareable_value(self, value): # -> None:
        ...
    
    @property
    def show(self): # -> bint:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        """
        ...
    
    @show.setter
    def show(self, value: bool): # -> None:
        ...
    
    @property
    def handlers(self): # -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        """
        ...
    
    @handlers.setter
    def handlers(self, value): # -> None:
        ...
    
    @property
    def theme(self): # -> baseTheme:
        """
        Writable attribute: bound theme for the item
        """
        ...
    
    @theme.setter
    def theme(self, value: baseTheme): # -> None:
        ...
    
    @property
    def pos_to_viewport(self): # -> object:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        """
        ...
    
    @property
    def pos_to_window(self): # -> object:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        """
        ...
    
    @property
    def pos_to_parent(self): # -> object:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        """
        ...
    
    @property
    def pos_to_default(self): # -> object:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        """
        ...
    
    @property
    def rect_size(self): # -> object:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        """
        ...
    
    @property
    def content_region_avail(self): # -> object:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        """
        ...
    
    @property
    def pos_policy(self): # -> positioning[]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        """
        ...
    
    @property
    def height(self): # -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
               For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        """
        ...
    
    @property
    def width(self): # -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        """
        ...
    
    @property
    def indent(self): # -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        """
        ...
    
    @property
    def no_newline(self): # -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        """
        ...
    
    @pos_to_viewport.setter
    def pos_to_viewport(self, value): # -> None:
        ...
    
    @pos_to_window.setter
    def pos_to_window(self, value): # -> None:
        ...
    
    @pos_to_parent.setter
    def pos_to_parent(self, value): # -> None:
        ...
    
    @pos_to_default.setter
    def pos_to_default(self, value): # -> None:
        ...
    
    @pos_policy.setter
    def pos_policy(self, value: positioning): # -> None:
        ...
    
    @height.setter
    def height(self, value: int): # -> None:
        ...
    
    @width.setter
    def width(self, value: int): # -> None:
        ...
    
    @indent.setter
    def indent(self, value: int): # -> None:
        ...
    
    @no_newline.setter
    def no_newline(self, value: bool): # -> None:
        ...
    


class SimplePlot(uiItem):
    def configure(self, **kwargs): # -> None:
        ...
    
    @property
    def scale_min(self): # -> float:
        """
        Writable attribute: value corresponding to the minimum value of plot scale
        """
        ...
    
    @scale_min.setter
    def scale_min(self, value: float): # -> None:
        ...
    
    @property
    def scale_max(self): # -> float:
        """
        Writable attribute: value corresponding to the maximum value of plot scale
        """
        ...
    
    @scale_max.setter
    def scale_max(self, value: float): # -> None:
        ...
    
    @property
    def histogram(self): # -> bint:
        """
        Writable attribute: Whether the data should be plotted as an histogram
        """
        ...
    
    @histogram.setter
    def histogram(self, value: bool): # -> None:
        ...
    
    @property
    def autoscale(self): # -> bint:
        """
        Writable attribute: Whether scale_min and scale_max should be deduced
        from the data
        """
        ...
    
    @autoscale.setter
    def autoscale(self, value: bool): # -> None:
        ...
    
    @property
    def overlay(self): # -> string:
        """
        Writable attribute: Overlay text
        """
        ...
    
    @overlay.setter
    def overlay(self, value: str): # -> None:
        ...
    


class Button(uiItem):
    @property
    def direction(self): # -> int:
        """
        Writable attribute: Direction of the arrow if any
        """
        ...
    
    @direction.setter
    def direction(self, value: int): # -> None:
        ...
    
    @property
    def small(self): # -> bint:
        """
        Writable attribute: Whether to display a small button
        """
        ...
    
    @small.setter
    def small(self, value: bool): # -> None:
        ...
    
    @property
    def arrow(self): # -> bint:
        """
        Writable attribute: Whether to display an arrow.
        Not compatible with small
        """
        ...
    
    @arrow.setter
    def arrow(self, value: bool): # -> None:
        ...
    
    @property
    def repeat(self): # -> bint:
        """
        Writable attribute: Whether to generate many clicked events
        when the button is held repeatedly, instead of a single.
        """
        ...
    
    @repeat.setter
    def repeat(self, value: bool): # -> None:
        ...
    


class Combo(uiItem):
    @property
    def items(self): # -> list[str]:
        """
        Writable attribute: List of text values to select
        """
        ...
    
    @items.setter
    def items(self, value): # -> None:
        ...
    
    @property
    def height_mode(self): # -> Literal['small', 'largest', 'large', 'regular']:
        """
        Writable attribute: height mode of the combo.
        Supported values are
        "small"
        "regular"
        "large"
        "largest"
        """
        ...
    
    @height_mode.setter
    def height_mode(self, value: str): # -> None:
        ...
    
    @property
    def popup_align_left(self): # -> bool:
        """
        Writable attribute: Whether to align left
        """
        ...
    
    @popup_align_left.setter
    def popup_align_left(self, value: bool): # -> None:
        ...
    
    @property
    def no_arrow_button(self): # -> bool:
        """
        Writable attribute: Whether the combo should not display an arrow on top
        """
        ...
    
    @no_arrow_button.setter
    def no_arrow_button(self, value: bool): # -> None:
        ...
    
    @property
    def no_preview(self): # -> bool:
        """
        Writable attribute: Whether the preview should be disabled
        """
        ...
    
    @no_preview.setter
    def no_preview(self, value: bool): # -> None:
        ...
    
    @property
    def fit_width(self): # -> bool:
        """
        Writable attribute: Whether the combo should fit available width
        """
        ...
    
    @fit_width.setter
    def fit_width(self, value: bool): # -> None:
        ...
    


class Checkbox(uiItem):
    ...


class Slider(uiItem):
    def configure(self, **kwargs): # -> None:
        ...
    
    @property
    def format(self): # -> Literal['float', 'int', 'double']:
        """
        Writable attribute: Format of the slider.
        Must be "int", "float" or "double".
        Note that float here means the 32 bits version.
        The python float corresponds to a double.
        """
        ...
    
    @format.setter
    def format(self, value: str): # -> None:
        ...
    
    @property
    def size(self): # -> int:
        """
        Writable attribute: Size of the slider.
        Can be 1, 2, 3 or 4.
        When 1 the item's value is held with
        a scalar shared value, else it is held
        with a vector of 4 elements (even for
        size 2 and 3)
        """
        ...
    
    @size.setter
    def size(self, target_size: int): # -> None:
        ...
    
    @property
    def clamped(self): # -> bool:
        """
        Writable attribute: Whether the slider value should be clamped even when keyboard set
        """
        ...
    
    @clamped.setter
    def clamped(self, value: bool): # -> None:
        ...
    
    @property
    def drag(self): # -> bint:
        """
        Writable attribute: Whether the use a 'drag'
        slider rather than a regular one.
        Incompatible with 'vertical'.
        """
        ...
    
    @drag.setter
    def drag(self, value: bool): # -> None:
        ...
    
    @property
    def logarithmic(self): # -> bool:
        """
        Writable attribute: Make the slider logarithmic.
        Disables round_to_format if enabled
        """
        ...
    
    @logarithmic.setter
    def logarithmic(self, value: bool): # -> None:
        ...
    
    @property
    def min_value(self): # -> double:
        """
        Writable attribute: Minimum value the slider
        will be clamped to.
        """
        ...
    
    @min_value.setter
    def min_value(self, value: float): # -> None:
        ...
    
    @property
    def max_value(self): # -> double:
        """
        Writable attribute: Maximum value the slider
        will be clamped to.
        """
        ...
    
    @max_value.setter
    def max_value(self, value: float): # -> None:
        ...
    
    @property
    def no_input(self): # -> bool:
        """
        Writable attribute: Disable Ctrl+Click and Enter key to
        manually set the value
        """
        ...
    
    @no_input.setter
    def no_input(self, value: bool): # -> None:
        ...
    
    @property
    def print_format(self): # -> str:
        """
        Writable attribute: format string
        for the value -> string conversion
        for display. If round_to_format is
        enabled, the value is converted
        back and thus appears rounded.
        """
        ...
    
    @print_format.setter
    def print_format(self, value: str): # -> None:
        ...
    
    @property
    def round_to_format(self): # -> bool:
        """
        Writable attribute: If set (default),
        the value will not have more digits precision
        than the requested format string for display.
        """
        ...
    
    @round_to_format.setter
    def round_to_format(self, value: bool): # -> None:
        ...
    
    @property
    def speed(self): # -> float:
        """
        Writable attribute: When drag is true,
        this attributes sets the drag speed.
        """
        ...
    
    @speed.setter
    def speed(self, value: float): # -> None:
        ...
    
    @property
    def vertical(self): # -> bint:
        """
        Writable attribute: Whether the use a vertical
        slider. Only sliders of size 1 and drag False
        are supported.
        """
        ...
    
    @vertical.setter
    def vertical(self, value: bool): # -> None:
        ...
    


class ListBox(uiItem):
    @property
    def items(self): # -> list[str]:
        """
        Writable attribute: List of text values to select
        """
        ...
    
    @items.setter
    def items(self, value): # -> None:
        ...
    
    @property
    def num_items_shown_when_open(self): # -> int:
        """
        Writable attribute: Number of items
        shown when the menu is opened
        """
        ...
    
    @num_items_shown_when_open.setter
    def num_items_shown_when_open(self, value: int): # -> None:
        ...
    


class RadioButton(uiItem):
    @property
    def items(self): # -> list[str]:
        """
        Writable attribute: List of text values to select
        """
        ...
    
    @items.setter
    def items(self, value): # -> None:
        ...
    
    @property
    def horizontal(self): # -> bint:
        """
        Writable attribute: Horizontal vs vertical placement
        """
        ...
    
    @horizontal.setter
    def horizontal(self, value: bool): # -> None:
        ...
    


class InputText(uiItem):
    @property
    def hint(self): # -> str:
        """
        Writable attribute: text hint.
        Doesn't work with multiline.
        """
        ...
    
    @hint.setter
    def hint(self, value: str): # -> None:
        ...
    
    @property
    def multiline(self): # -> bint:
        """
        Writable attribute: multiline text input.
        Doesn't work with non-empty hint.
        """
        ...
    
    @multiline.setter
    def multiline(self, value: bool): # -> None:
        ...
    
    @property
    def max_characters(self): # -> int:
        """
        Writable attribute: Maximal number of characters that can be written
        """
        ...
    
    @max_characters.setter
    def max_characters(self, value: int): # -> None:
        ...
    
    @property
    def decimal(self): # -> bool:
        """
        Writable attribute: Allow 0123456789.+-
        """
        ...
    
    @decimal.setter
    def decimal(self, value: bool): # -> None:
        ...
    
    @property
    def hexadecimal(self): # -> bool:
        """
        Writable attribute:  Allow 0123456789ABCDEFabcdef
        """
        ...
    
    @hexadecimal.setter
    def hexadecimal(self, value: bool): # -> None:
        ...
    
    @property
    def scientific(self): # -> bool:
        """
        Writable attribute: Allow 0123456789.+-*/eE
        """
        ...
    
    @scientific.setter
    def scientific(self, value: bool): # -> None:
        ...
    
    @property
    def uppercase(self): # -> bool:
        """
        Writable attribute: Turn a..z into A..Z
        """
        ...
    
    @uppercase.setter
    def uppercase(self, value: bool): # -> None:
        ...
    
    @property
    def no_spaces(self): # -> bool:
        """
        Writable attribute: Filter out spaces, tabs
        """
        ...
    
    @no_spaces.setter
    def no_spaces(self, value: bool): # -> None:
        ...
    
    @property
    def tab_input(self): # -> bool:
        """
        Writable attribute: Pressing TAB input a '\t' character into the text field
        """
        ...
    
    @tab_input.setter
    def tab_input(self, value: bool): # -> None:
        ...
    
    @property
    def on_enter(self): # -> bool:
        """
        Writable attribute: Callback called everytime Enter is pressed,
        not just when the value is modified.
        """
        ...
    
    @on_enter.setter
    def on_enter(self, value: bool): # -> None:
        ...
    
    @property
    def escape_clears_all(self): # -> bool:
        """
        Writable attribute: Escape key clears content if not empty,
        and deactivate otherwise
        (contrast to default behavior of Escape to revert)
        """
        ...
    
    @escape_clears_all.setter
    def escape_clears_all(self, value: bool): # -> None:
        ...
    
    @property
    def ctrl_enter_for_new_line(self): # -> bool:
        """
        Writable attribute: In multi-line mode, validate with Enter,
        add new line with Ctrl+Enter
        (default is opposite: validate with Ctrl+Enter, add line with Enter).
        """
        ...
    
    @ctrl_enter_for_new_line.setter
    def ctrl_enter_for_new_line(self, value: bool): # -> None:
        ...
    
    @property
    def readonly(self): # -> bool:
        """
        Writable attribute: Read-only mode
        """
        ...
    
    @readonly.setter
    def readonly(self, value: bool): # -> None:
        ...
    
    @property
    def password(self): # -> bool:
        """
        Writable attribute: Password mode, display all characters as '*', disable copy
        """
        ...
    
    @password.setter
    def password(self, value: bool): # -> None:
        ...
    
    @property
    def always_overwrite(self): # -> bool:
        """
        Writable attribute: Overwrite mode
        """
        ...
    
    @always_overwrite.setter
    def always_overwrite(self, value: bool): # -> None:
        ...
    
    @property
    def auto_select_all(self): # -> bool:
        """
        Writable attribute: Select entire text when first taking mouse focus
        """
        ...
    
    @auto_select_all.setter
    def auto_select_all(self, value: bool): # -> None:
        ...
    
    @property
    def no_horizontal_scroll(self): # -> bool:
        """
        Writable attribute: Disable following the scroll horizontally
        """
        ...
    
    @no_horizontal_scroll.setter
    def no_horizontal_scroll(self, value: bool): # -> None:
        ...
    
    @property
    def no_undo_redo(self): # -> bool:
        """
        Writable attribute: Disable undo/redo.
        """
        ...
    
    @no_undo_redo.setter
    def no_undo_redo(self, value: bool): # -> None:
        ...
    


class InputValue(uiItem):
    def configure(self, **kwargs): # -> None:
        ...
    
    @property
    def format(self): # -> Literal['float', 'int', 'double']:
        """
        Writable attribute: Format of the slider.
        Must be "int", "float" or "double".
        Note that float here means the 32 bits version.
        The python float corresponds to a double.
        """
        ...
    
    @format.setter
    def format(self, value: str): # -> None:
        ...
    
    @property
    def size(self): # -> int:
        """
        Writable attribute: Size of the slider.
        Can be 1, 2, 3 or 4.
        When 1 the item's value is held with
        a scalar shared value, else it is held
        with a vector of 4 elements (even for
        size 2 and 3)
        """
        ...
    
    @size.setter
    def size(self, target_size: int): # -> None:
        ...
    
    @property
    def step(self): # -> double:
        """
        Writable attribute: 
        """
        ...
    
    @step.setter
    def step(self, value: float): # -> None:
        ...
    
    @property
    def step_fast(self): # -> double:
        """
        Writable attribute: 
        """
        ...
    
    @step_fast.setter
    def step_fast(self, value: float): # -> None:
        ...
    
    @property
    def min_value(self): # -> double:
        """
        Writable attribute: Minimum value the input
        will be clamped to.
        """
        ...
    
    @min_value.setter
    def min_value(self, value: float): # -> None:
        ...
    
    @property
    def max_value(self): # -> double:
        """
        Writable attribute: Maximum value the input
        will be clamped to.
        """
        ...
    
    @max_value.setter
    def max_value(self, value: float): # -> None:
        ...
    
    @property
    def print_format(self): # -> str:
        """
        Writable attribute: format string
        for the value -> string conversion
        for display. If round_to_format is
        enabled, the value is converted
        back and thus appears rounded.
        """
        ...
    
    @print_format.setter
    def print_format(self, value: str): # -> None:
        ...
    
    @property
    def decimal(self): # -> bool:
        """
        Writable attribute: Allow 0123456789.+-
        """
        ...
    
    @decimal.setter
    def decimal(self, value: bool): # -> None:
        ...
    
    @property
    def hexadecimal(self): # -> bool:
        """
        Writable attribute:  Allow 0123456789ABCDEFabcdef
        """
        ...
    
    @hexadecimal.setter
    def hexadecimal(self, value: bool): # -> None:
        ...
    
    @property
    def scientific(self): # -> bool:
        """
        Writable attribute: Allow 0123456789.+-*/eE
        """
        ...
    
    @scientific.setter
    def scientific(self, value: bool): # -> None:
        ...
    
    @property
    def on_enter(self): # -> bool:
        """
        Writable attribute: Callback called everytime Enter is pressed,
        not just when the value is modified.
        """
        ...
    
    @on_enter.setter
    def on_enter(self, value: bool): # -> None:
        ...
    
    @property
    def escape_clears_all(self): # -> bool:
        """
        Writable attribute: Escape key clears content if not empty,
        and deactivate otherwise
        (contrast to default behavior of Escape to revert)
        """
        ...
    
    @escape_clears_all.setter
    def escape_clears_all(self, value: bool): # -> None:
        ...
    
    @property
    def readonly(self): # -> bool:
        """
        Writable attribute: Read-only mode
        """
        ...
    
    @readonly.setter
    def readonly(self, value: bool): # -> None:
        ...
    
    @property
    def password(self): # -> bool:
        """
        Writable attribute: Password mode, display all characters as '*', disable copy
        """
        ...
    
    @password.setter
    def password(self, value: bool): # -> None:
        ...
    
    @property
    def always_overwrite(self): # -> bool:
        """
        Writable attribute: Overwrite mode
        """
        ...
    
    @always_overwrite.setter
    def always_overwrite(self, value: bool): # -> None:
        ...
    
    @property
    def auto_select_all(self): # -> bool:
        """
        Writable attribute: Select entire text when first taking mouse focus
        """
        ...
    
    @auto_select_all.setter
    def auto_select_all(self, value: bool): # -> None:
        ...
    
    @property
    def empty_as_zero(self): # -> bool:
        """
        Writable attribute: parse empty string as zero value
        """
        ...
    
    @empty_as_zero.setter
    def empty_as_zero(self, value: bool): # -> None:
        ...
    
    @property
    def empty_if_zero(self): # -> bool:
        """
        Writable attribute: when value is zero, do not display it
        """
        ...
    
    @empty_if_zero.setter
    def empty_if_zero(self, value: bool): # -> None:
        ...
    
    @property
    def no_horizontal_scroll(self): # -> bool:
        """
        Writable attribute: Disable following the scroll horizontally
        """
        ...
    
    @no_horizontal_scroll.setter
    def no_horizontal_scroll(self, value: bool): # -> None:
        ...
    
    @property
    def no_undo_redo(self): # -> bool:
        """
        Writable attribute: Disable undo/redo.
        """
        ...
    
    @no_undo_redo.setter
    def no_undo_redo(self, value: bool): # -> None:
        ...
    


class Text(uiItem):
    @property
    def color(self): # -> int:
        """
        Writable attribute: text color.
        If set to 0 (default), that is
        full transparent text, use the
        default value given by the style
        """
        ...
    
    @color.setter
    def color(self, value): # -> None:
        ...
    
    @property
    def label(self): # -> str:
        ...
    
    @label.setter
    def label(self, value: str): # -> None:
        ...
    
    @property
    def wrap(self): # -> int:
        """
        Writable attribute: wrap width in pixels
        -1 for no wrapping
        """
        ...
    
    @wrap.setter
    def wrap(self, value: int): # -> None:
        ...
    
    @property
    def bullet(self): # -> bint:
        """
        Writable attribute: Whether to add a bullet
        before the text
        """
        ...
    
    @bullet.setter
    def bullet(self, value: bool): # -> None:
        ...
    
    @property
    def show_label(self): # -> bint:
        """
        Writable attribute: Whether to display the
        label next to the text stored in value
        """
        ...
    
    @show_label.setter
    def show_label(self, value: bool): # -> None:
        ...
    


class Selectable(uiItem):
    @property
    def disable_popup_close(self): # -> bool:
        """
        Writable attribute: Clicking this doesn't close parent popup window
        """
        ...
    
    @disable_popup_close.setter
    def disable_popup_close(self, value: bool): # -> None:
        ...
    
    @property
    def span_columns(self): # -> bool:
        """
        Writable attribute: Frame will span all columns of its container table (text will still fit in current column)
        """
        ...
    
    @span_columns.setter
    def span_columns(self, value: bool): # -> None:
        ...
    
    @property
    def on_double_click(self): # -> bool:
        """
        Writable attribute: call callbacks on double clicks too
        """
        ...
    
    @on_double_click.setter
    def on_double_click(self, value: bool): # -> None:
        ...
    
    @property
    def highlighted(self): # -> bool:
        """
        Writable attribute: highlighted as if hovered
        """
        ...
    
    @highlighted.setter
    def highlighted(self, value: bool): # -> None:
        ...
    


class MenuItem(uiItem):
    @property
    def check(self): # -> bint:
        """
        Writable attribute:
        """
        ...
    
    @check.setter
    def check(self, value: bool): # -> None:
        ...
    
    @property
    def shortcut(self): # -> str:
        """
        Writable attribute:
        """
        ...
    
    @shortcut.setter
    def shortcut(self, value: str): # -> None:
        ...
    


class ProgressBar(uiItem):
    @property
    def overlay(self): # -> str:
        """
        Writable attribute:
        """
        ...
    
    @overlay.setter
    def overlay(self, value: str): # -> None:
        ...
    


class Image(uiItem):
    @property
    def texture(self): # -> Texture:
        ...
    
    @texture.setter
    def texture(self, value): # -> None:
        ...
    
    @property
    def uv(self): # -> list:
        ...
    
    @uv.setter
    def uv(self, value): # -> None:
        ...
    
    @property
    def color_multiplier(self): # -> list:
        ...
    
    @color_multiplier.setter
    def color_multiplier(self, value): # -> None:
        ...
    
    @property
    def border_color(self): # -> list:
        ...
    
    @border_color.setter
    def border_color(self, value): # -> None:
        ...
    


class ImageButton(uiItem):
    @property
    def texture(self): # -> Texture:
        ...
    
    @texture.setter
    def texture(self, value): # -> None:
        ...
    
    @property
    def frame_padding(self): # -> int:
        ...
    
    @frame_padding.setter
    def frame_padding(self, value: int): # -> None:
        ...
    
    @property
    def uv(self): # -> list:
        ...
    
    @uv.setter
    def uv(self, value): # -> None:
        ...
    
    @property
    def color_multiplier(self): # -> list:
        ...
    
    @color_multiplier.setter
    def color_multiplier(self, value): # -> None:
        ...
    
    @property
    def background_color(self): # -> list:
        ...
    
    @background_color.setter
    def background_color(self, value): # -> None:
        ...
    


class Separator(uiItem):
    @property
    def label(self): # -> str:
        ...
    
    @label.setter
    def label(self, value: str): # -> None:
        ...
    


class Spacer(uiItem):
    ...


class MenuBar(uiItem):
    ...


class Menu(uiItem):
    ...


class Tooltip(uiItem):
    @property
    def target(self): # -> baseItem:
        """
        Target item which state will be checked
        to trigger the tooltip.
        Note if the item is after this tooltip
        in the rendering tree, there will be
        a frame delay.
        If no target is set, the previous sibling
        is the target.
        If the target is not the previous sibling,
        delay will have no effect.
        """
        ...
    
    @target.setter
    def target(self, target: baseItem): # -> None:
        ...
    
    @property
    def condition_from_handler(self): # -> baseHandler:
        """
        When set, the handler referenced in
        this field will be used to replace
        the target hovering check. It will
        apply to target, which must be set.
        """
        ...
    
    @condition_from_handler.setter
    def condition_from_handler(self, handler: baseHandler): # -> None:
        ...
    
    @property
    def delay(self): # -> float:
        """
        Delay in seconds with no motion before showing the tooltip
        -1: Use imgui defaults
        Has no effect if the target is not the previous sibling,
        or if condition_from_handler is set.
        """
        ...
    
    @delay.setter
    def delay(self, value: float): # -> None:
        ...
    
    @property
    def hide_on_activity(self): # -> float:
        """
        Hide the tooltip when the mouse moves
        """
        ...
    
    @hide_on_activity.setter
    def hide_on_activity(self, value: float): # -> None:
        ...
    


class TabButton(uiItem):
    @property
    def no_reorder(self): # -> bool:
        """
        Writable attribute: Disable reordering this tab or
        having another tab cross over this tab
        """
        ...
    
    @no_reorder.setter
    def no_reorder(self, value: bool): # -> None:
        ...
    
    @property
    def leading(self): # -> bool:
        """
        Writable attribute: Enforce the tab position to the
        left of the tab bar (after the tab list popup button)
        """
        ...
    
    @leading.setter
    def leading(self, value: bool): # -> None:
        ...
    
    @property
    def trailing(self): # -> bool:
        """
        Writable attribute: Enforce the tab position to the
        right of the tab bar (before the scrolling buttons)
        """
        ...
    
    @trailing.setter
    def trailing(self, value: bool): # -> None:
        ...
    
    @property
    def no_tooltip(self): # -> bool:
        """
        Writable attribute: Disable tooltip for the given tab
        """
        ...
    
    @no_tooltip.setter
    def no_tooltip(self, value: bool): # -> None:
        ...
    


class Tab(uiItem):
    @property
    def closable(self): # -> bint:
        """
        Writable attribute: Can the tab be closed
        """
        ...
    
    @closable.setter
    def closable(self, value: bool): # -> None:
        ...
    
    @property
    def no_reorder(self): # -> bool:
        """
        Writable attribute: Disable reordering this tab or
        having another tab cross over this tab
        """
        ...
    
    @no_reorder.setter
    def no_reorder(self, value: bool): # -> None:
        ...
    
    @property
    def leading(self): # -> bool:
        """
        Writable attribute: Enforce the tab position to the
        left of the tab bar (after the tab list popup button)
        """
        ...
    
    @leading.setter
    def leading(self, value: bool): # -> None:
        ...
    
    @property
    def trailing(self): # -> bool:
        """
        Writable attribute: Enforce the tab position to the
        right of the tab bar (before the scrolling buttons)
        """
        ...
    
    @trailing.setter
    def trailing(self, value: bool): # -> None:
        ...
    
    @property
    def no_tooltip(self): # -> bool:
        """
        Writable attribute: Disable tooltip for the given tab
        """
        ...
    
    @no_tooltip.setter
    def no_tooltip(self, value: bool): # -> None:
        ...
    


class TabBar(uiItem):
    @property
    def reorderable(self): # -> bool:
        """
        Writable attribute: Allow manually dragging tabs
        to re-order them + New tabs are appended at the end of list
        """
        ...
    
    @reorderable.setter
    def reorderable(self, value: bool): # -> None:
        ...
    
    @property
    def autoselect_new_tabs(self): # -> bool:
        """
        Writable attribute: Automatically select new
        tabs when they appear
        """
        ...
    
    @autoselect_new_tabs.setter
    def autoselect_new_tabs(self, value: bool): # -> None:
        ...
    
    @property
    def no_tab_list_popup_button(self): # -> bool:
        """
        Writable attribute: Disable buttons to open the tab list popup
        """
        ...
    
    @no_tab_list_popup_button.setter
    def no_tab_list_popup_button(self, value: bool): # -> None:
        ...
    
    @property
    def no_close_with_middle_mouse_button(self): # -> bool:
        """
        Writable attribute: Disable behavior of closing tabs with middle mouse button.
        """
        ...
    
    @no_close_with_middle_mouse_button.setter
    def no_close_with_middle_mouse_button(self, value: bool): # -> None:
        ...
    
    @property
    def no_scrolling_button(self): # -> bool:
        """
        Writable attribute: Disable scrolling buttons
        """
        ...
    
    @no_scrolling_button.setter
    def no_scrolling_button(self, value: bool): # -> None:
        ...
    
    @property
    def no_tooltip(self): # -> bool:
        """
        Writable attribute: Disable tooltip for all tabs
        """
        ...
    
    @no_tooltip.setter
    def no_tooltip(self, value: bool): # -> None:
        ...
    
    @property
    def selected_overline(self): # -> bool:
        """
        Writable attribute: Draw selected overline markers over selected tab
        """
        ...
    
    @selected_overline.setter
    def selected_overline(self, value: bool): # -> None:
        ...
    
    @property
    def resize_to_fit(self): # -> bool:
        """
        Writable attribute: Resize tabs when they don't fit
        """
        ...
    
    @resize_to_fit.setter
    def resize_to_fit(self, value: bool): # -> None:
        ...
    
    @property
    def allow_tab_scroll(self): # -> bool:
        """
        Writable attribute: Add scroll buttons when tabs don't fit
        """
        ...
    
    @allow_tab_scroll.setter
    def allow_tab_scroll(self, value: bool): # -> None:
        ...
    


class Layout(uiItem):
    """
    A layout is a group of elements organized
    together.
    The layout states correspond to the OR
    of all the item states, and the rect size
    corresponds to the minimum rect containing
    all the items. The position of the layout
    is used to initialize the default position
    for the first item.
    For example setting indent will shift all
    the items of the Layout.

    Subclassing Layout:
    For custom layouts, you can use Layout with
    a callback. The callback is called whenever
    the layout should be updated.

    If the automated update detection is not
    sufficient, update_layout() can be called
    to force a recomputation of the layout.

    Currently the update detection detects a change in
    the size of the remaining content area available
    locally within the window, or if the last item has changed.

    The layout item works by changing the positioning
    policy and the target position of its children, and
    thus there is no guarantee that the user set
    positioning and position states of the children are
    preserved.
    """
    def update_layout(self): # -> None:
        ...
    


class HorizontalLayout(Layout):
    """
    A basic layout to organize the items
    horizontally.
    """
    @property
    def alignment_mode(self): # -> alignment:
        """
        Horizontal alignment mode of the items.
        LEFT: items are appended from the left
        RIGHT: items are appended from the right
        CENTER: items are centered
        JUSTIFIED: spacing is organized such
        that items start at the left and end
        at the right.
        MANUAL: items are positionned at the requested
        positions

        FOR LEFT/RIGHT/CENTER, spacing can be used
        to add additional spacing between the items.
        Default is LEFT.
        """
        ...
    
    @alignment_mode.setter
    def alignment_mode(self, value: alignment): # -> None:
        ...
    
    @property
    def spacing(self): # -> alignment:
        """
        Additional space to add between items.
        Doesn't have effect with JUSTIFIED or MANUAL.
        """
        ...
    
    @spacing.setter
    def spacing(self, value: float): # -> None:
        ...
    
    @property
    def positions(self): # -> vector[float]:
        """
        When in MANUAL mode, the x position starting
        from the top left of this item at which to
        place the children items.

        If the positions are between 0 and 1, they are
        interpreted as percentages relative to the
        size of the Layout width.
        If the positions are negatives, they are interpreted
        as in reference to the right of the layout rather
        than the left. Items are still left aligned to
        the target position though.

        Setting this field sets the alignment mode to
        MANUAL.
        """
        ...
    
    @positions.setter
    def positions(self, value): # -> None:
        ...
    
    def update_layout(self): # -> None:
        ...
    


class VerticalLayout(Layout):
    """
    Same as HorizontalLayout but vertically
    """
    @property
    def alignment_mode(self): # -> alignment:
        """
        Vertical alignment mode of the items.
        TOP: items are appended from the top
        BOTTOM: items are appended from the BOTTOM
        CENTER: items are centered
        JUSTIFIED: spacing is organized such
        that items start at the TOP and end
        at the BOTTOM.
        MANUAL: items are positionned at the requested
        positions

        FOR TOP/BOTTOM/CENTER, spacing can be used
        to add additional spacing between the items.
        Default is TOP.
        """
        ...
    
    @alignment_mode.setter
    def alignment_mode(self, value: alignment): # -> None:
        ...
    
    @property
    def spacing(self): # -> alignment:
        """
        Additional space to add between items.
        Doesn't have effect with JUSTIFIED or MANUAL.
        """
        ...
    
    @spacing.setter
    def spacing(self, value: float): # -> None:
        ...
    
    @property
    def positions(self): # -> vector[float]:
        """
        When in MANUAL mode, the y position starting
        from the top left of this item at which to
        place the children items.

        If the positions are between 0 and 1, they are
        interpreted as percentages relative to the
        size of the Layout height.
        If the positions are negatives, they are interpreted
        as in reference to the bottom of the layout rather
        than the top. Items are still top aligned to
        the target position though.

        Setting this field sets the alignment mode to
        MANUAL.
        """
        ...
    
    @positions.setter
    def positions(self, value): # -> None:
        ...
    
    def update_layout(self): # -> None:
        ...
    


class TreeNode(uiItem):
    @property
    def selectable(self): # -> bint:
        """
        Writable attribute: Draw the TreeNode as selected when opened
        """
        ...
    
    @selectable.setter
    def selectable(self, value: bool): # -> None:
        ...
    
    @property
    def default_open(self): # -> bool:
        """
        Writable attribute: Default node to be open
        """
        ...
    
    @default_open.setter
    def default_open(self, value: bool): # -> None:
        ...
    
    @property
    def open_on_double_click(self): # -> bool:
        """
        Writable attribute: Need double-click to open node
        """
        ...
    
    @open_on_double_click.setter
    def open_on_double_click(self, value: bool): # -> None:
        ...
    
    @property
    def open_on_arrow(self): # -> bool:
        """
        Writable attribute:  Only open when clicking on the arrow part.
        If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
        single-click arrow or double-click all box to open.
        """
        ...
    
    @open_on_arrow.setter
    def open_on_arrow(self, value: bool): # -> None:
        ...
    
    @property
    def leaf(self): # -> bool:
        """
        Writable attribute: No collapsing, no arrow (use as a convenience for leaf nodes).
        """
        ...
    
    @leaf.setter
    def leaf(self, value: bool): # -> None:
        ...
    
    @property
    def bullet(self): # -> bool:
        """
        Writable attribute: Display a bullet instead of arrow.
        IMPORTANT: node can still be marked open/close if
        you don't set the _Leaf flag!
        """
        ...
    
    @bullet.setter
    def bullet(self, value: bool): # -> None:
        ...
    
    @property
    def span_text_width(self): # -> bool:
        """
        Writable attribute: Narrow hit box + narrow hovering
        highlight, will only cover the label text.
        """
        ...
    
    @span_text_width.setter
    def span_text_width(self, value: bool): # -> None:
        ...
    
    @property
    def span_full_width(self): # -> bool:
        """
        Writable attribute: Extend hit box to the left-most
        and right-most edges (cover the indent area).
        """
        ...
    
    @span_full_width.setter
    def span_full_width(self, value: bool): # -> None:
        ...
    


class CollapsingHeader(uiItem):
    @property
    def closable(self): # -> bint:
        """
        Writable attribute: Display a close button
        """
        ...
    
    @closable.setter
    def closable(self, value: bool): # -> None:
        ...
    
    @property
    def open_on_double_click(self): # -> bool:
        """
        Writable attribute: Need double-click to open node
        """
        ...
    
    @open_on_double_click.setter
    def open_on_double_click(self, value: bool): # -> None:
        ...
    
    @property
    def open_on_arrow(self): # -> bool:
        """
        Writable attribute:  Only open when clicking on the arrow part.
        If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
        single-click arrow or double-click all box to open.
        """
        ...
    
    @open_on_arrow.setter
    def open_on_arrow(self, value: bool): # -> None:
        ...
    
    @property
    def leaf(self): # -> bool:
        """
        Writable attribute: No collapsing, no arrow (use as a convenience for leaf nodes).
        """
        ...
    
    @leaf.setter
    def leaf(self, value: bool): # -> None:
        ...
    
    @property
    def bullet(self): # -> bool:
        """
        Writable attribute: Display a bullet instead of arrow.
        IMPORTANT: node can still be marked open/close if
        you don't set the _Leaf flag!
        """
        ...
    
    @bullet.setter
    def bullet(self, value: bool): # -> None:
        ...
    


class ChildWindow(uiItem):
    @property
    def always_show_vertical_scrollvar(self): # -> bool:
        """
        Writable attribute to tell to always show a vertical scrollbar
        even when the size does not require it
        """
        ...
    
    @always_show_vertical_scrollvar.setter
    def always_show_vertical_scrollvar(self, value: bool): # -> None:
        ...
    
    @property
    def always_show_horizontal_scrollvar(self): # -> bool:
        """
        Writable attribute to tell to always show a horizontal scrollbar
        even when the size does not require it (only if horizontal scrollbar
        are enabled)
        """
        ...
    
    @always_show_horizontal_scrollvar.setter
    def always_show_horizontal_scrollvar(self, value: bool): # -> None:
        ...
    
    @property
    def no_scrollbar(self): # -> bool:
        """Writable attribute to indicate the window should have no scrollbar
           Does not disable scrolling via mouse or keyboard
        """
        ...
    
    @no_scrollbar.setter
    def no_scrollbar(self, value: bool): # -> None:
        ...
    
    @property
    def horizontal_scrollbar(self): # -> bool:
        """
        Writable attribute to enable having an horizontal scrollbar
        """
        ...
    
    @horizontal_scrollbar.setter
    def horizontal_scrollbar(self, value: bool): # -> None:
        ...
    
    @property
    def menubar(self): # -> bool:
        """
        Writable attribute to indicate whether the window has a menu bar.

        There will be menubar if either the user has asked for it,
        or there is a menubar child.
        """
        ...
    
    @menubar.setter
    def menubar(self, value: bool): # -> None:
        ...
    
    @property
    def no_scroll_with_mouse(self): # -> bool:
        """
        Writable attribute: mouse wheel will be forwarded to the parent
        unless NoScrollbar is also set.
        """
        ...
    
    @no_scroll_with_mouse.setter
    def no_scroll_with_mouse(self, value: bool): # -> None:
        ...
    
    @property
    def flattened_navigation(self): # -> bool:
        """
        Writable attribute: share focus scope, allow gamepad/keyboard
        navigation to cross over parent border to this child or
        between sibling child windows.
        Defaults to True.
        """
        ...
    
    @flattened_navigation.setter
    def flattened_navigation(self, value: bool): # -> None:
        ...
    
    @property
    def border(self): # -> bool:
        """
        Writable attribute: show an outer border and enable WindowPadding.
        Defaults to True.
        """
        ...
    
    @border.setter
    def border(self, value: bool): # -> None:
        ...
    
    @property
    def always_auto_resize(self): # -> bool:
        """
        Writable attribute: combined with AutoResizeX/AutoResizeY.
        Always measure size even when child is hidden,
        Note the item will render its children even if hidden.
        """
        ...
    
    @always_auto_resize.setter
    def always_auto_resize(self, value: bool): # -> None:
        ...
    
    @property
    def always_use_window_padding(self): # -> bool:
        """
        Writable attribute: pad with style WindowPadding even if
        no border are drawn (no padding by default for non-bordered
        child windows)
        """
        ...
    
    @always_use_window_padding.setter
    def always_use_window_padding(self, value: bool): # -> None:
        ...
    
    @property
    def auto_resize_x(self): # -> bool:
        """
        Writable attribute: enable auto-resizing width based on the content
        Set instead width to 0 to use the remaining size of the parent
        """
        ...
    
    @auto_resize_x.setter
    def auto_resize_x(self, value: bool): # -> None:
        ...
    
    @property
    def auto_resize_y(self): # -> bool:
        """
        Writable attribute: enable auto-resizing height based on the content
        Set instead height to 0 to use the remaining size of the parent
        """
        ...
    
    @auto_resize_y.setter
    def auto_resize_y(self, value: bool): # -> None:
        ...
    
    @property
    def frame_style(self): # -> bool:
        """
        Writable attribute: if set, style the child window like a framed item.
        That is: use FrameBg, FrameRounding, FrameBorderSize, FramePadding
        instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
        """
        ...
    
    @frame_style.setter
    def frame_style(self, value: bool): # -> None:
        ...
    
    @property
    def resizable_x(self): # -> bool:
        """
        Writable attribute: allow resize from right border (layout direction).
        """
        ...
    
    @resizable_x.setter
    def resizable_x(self, value: bool): # -> None:
        ...
    
    @property
    def resizable_y(self): # -> bool:
        """
        Writable attribute: allow resize from bottom border (layout direction).
        """
        ...
    
    @resizable_y.setter
    def resizable_y(self, value: bool): # -> None:
        ...
    


class ColorButton(uiItem):
    @property
    def no_alpha(self): # -> bool:
        """
        Writable attribute: ignore Alpha component (will only read 3 components from the input pointer)
        """
        ...
    
    @no_alpha.setter
    def no_alpha(self, value: bool): # -> None:
        ...
    
    @property
    def no_tooltip(self): # -> bool:
        """
        Writable attribute: disable default tooltip when hovering the preview
        """
        ...
    
    @no_tooltip.setter
    def no_tooltip(self, value: bool): # -> None:
        ...
    
    @property
    def no_drag_drop(self): # -> bool:
        """
        Writable attribute: disable drag and drop source
        """
        ...
    
    @no_drag_drop.setter
    def no_drag_drop(self, value: bool): # -> None:
        ...
    
    @property
    def no_border(self): # -> bool:
        """
        Writable attribute: disable the default border
        """
        ...
    
    @no_border.setter
    def no_border(self, value: bool): # -> None:
        ...
    


class ColorEdit(uiItem):
    @property
    def no_alpha(self): # -> bool:
        """
        Writable attribute: ignore Alpha component (will only read 3 components from the input pointer)
        """
        ...
    
    @no_alpha.setter
    def no_alpha(self, value: bool): # -> None:
        ...
    
    @property
    def no_picker(self): # -> bool:
        """
        Writable attribute: disable picker when clicking on color square.
        """
        ...
    
    @no_picker.setter
    def no_picker(self, value: bool): # -> None:
        ...
    
    @property
    def no_options(self): # -> bool:
        """
        Writable attribute: disable toggling options menu when right-clicking on inputs/small preview.
        """
        ...
    
    @no_options.setter
    def no_options(self, value: bool): # -> None:
        ...
    
    @property
    def no_small_preview(self): # -> bool:
        """
        Writable attribute: disable color square preview next to the inputs. (e.g. to show only the inputs)
        """
        ...
    
    @no_small_preview.setter
    def no_small_preview(self, value: bool): # -> None:
        ...
    
    @property
    def no_inputs(self): # -> bool:
        """
        Writable attribute: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        """
        ...
    
    @no_inputs.setter
    def no_inputs(self, value: bool): # -> None:
        ...
    
    @property
    def no_tooltip(self): # -> bool:
        """
        Writable attribute: disable default tooltip when hovering the preview
        """
        ...
    
    @no_tooltip.setter
    def no_tooltip(self, value: bool): # -> None:
        ...
    
    @property
    def no_label(self): # -> bool:
        """
        Writable attribute: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        """
        ...
    
    @no_label.setter
    def no_label(self, value: bool): # -> None:
        ...
    
    @property
    def no_drag_drop(self): # -> bool:
        """
        Writable attribute: disable drag and drop target
        """
        ...
    
    @no_drag_drop.setter
    def no_drag_drop(self, value: bool): # -> None:
        ...
    


class ColorPicker(uiItem):
    @property
    def no_alpha(self): # -> bool:
        """
        Writable attribute: ignore Alpha component (will only read 3 components from the input pointer)
        """
        ...
    
    @no_alpha.setter
    def no_alpha(self, value: bool): # -> None:
        ...
    
    @property
    def no_small_preview(self): # -> bool:
        """
        Writable attribute: disable color square preview next to the inputs. (e.g. to show only the inputs)
        """
        ...
    
    @no_small_preview.setter
    def no_small_preview(self, value: bool): # -> None:
        ...
    
    @property
    def no_inputs(self): # -> bool:
        """
        Writable attribute: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        """
        ...
    
    @no_inputs.setter
    def no_inputs(self, value: bool): # -> None:
        ...
    
    @property
    def no_tooltip(self): # -> bool:
        """
        Writable attribute: disable default tooltip when hovering the preview
        """
        ...
    
    @no_tooltip.setter
    def no_tooltip(self, value: bool): # -> None:
        ...
    
    @property
    def no_label(self): # -> bool:
        """
        Writable attribute: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        """
        ...
    
    @no_label.setter
    def no_label(self, value: bool): # -> None:
        ...
    
    @property
    def no_side_preview(self): # -> bool:
        """
        Writable attribute: disable bigger color preview on right side of the picker, use small color square preview instead.
        """
        ...
    
    @no_side_preview.setter
    def no_side_preview(self, value: bool): # -> None:
        ...
    


class TimeWatcher(uiItem):
    """
    A placeholder uiItem that doesn't draw
    or have any impact on rendering.
    This item calls the callback with times in ns.
    These times can be compared with the times in the metrics
    that can be obtained from the viewport in order to
    precisely figure out the time spent rendering specific items.

    The first time corresponds to the time when the next sibling
    requested this sibling to render. At this step, no sibling
    of this item (previous or next) have rendered anything.

    The second time corresponds to the time when the previous
    siblings have finished rendering and it is now the turn
    of this item to render. Next items have not rendered yet.

    The third time corresponds to the time when viewport
    started rendering items for this frame. It is a duplicate of
    context.viewport.metrics.last_t_before_rendering. It is
    given to prevent the user from having to keep track of the
    viewport metrics (since the callback might be called
    after or before the viewport updated its metrics for this
    frame or another one).

    The fourth number corresponds to the frame count
    at the the time the callback was issued.

    Note the times relate to CPU time (checking states, preparing
    GPU data, etc), not to GPU rendering time.
    """
    ...


class Window(uiItem):
    @property
    def no_title_bar(self): # -> bool:
        """Writable attribute to disable the title-bar"""
        ...
    
    @no_title_bar.setter
    def no_title_bar(self, value: bool): # -> None:
        ...
    
    @property
    def no_resize(self): # -> bool:
        """Writable attribute to block resizing"""
        ...
    
    @no_resize.setter
    def no_resize(self, value: bool): # -> None:
        ...
    
    @property
    def no_move(self): # -> bool:
        """Writable attribute the window to be move with interactions"""
        ...
    
    @no_move.setter
    def no_move(self, value: bool): # -> None:
        ...
    
    @property
    def no_scrollbar(self): # -> bool:
        """Writable attribute to indicate the window should have no scrollbar
           Does not disable scrolling via mouse or keyboard
        """
        ...
    
    @no_scrollbar.setter
    def no_scrollbar(self, value: bool): # -> None:
        ...
    
    @property
    def no_scroll_with_mouse(self): # -> bool:
        """Writable attribute to indicate the mouse wheel
           should have no effect on scrolling of this window
        """
        ...
    
    @no_scroll_with_mouse.setter
    def no_scroll_with_mouse(self, value: bool): # -> None:
        ...
    
    @property
    def no_collapse(self): # -> bool:
        """Writable attribute to disable user collapsing window by double-clicking on it
        """
        ...
    
    @no_collapse.setter
    def no_collapse(self, value: bool): # -> None:
        ...
    
    @property
    def autosize(self): # -> bool:
        """Writable attribute to tell the window should
           automatically resize to fit its content
        """
        ...
    
    @autosize.setter
    def autosize(self, value: bool): # -> None:
        ...
    
    @property
    def no_background(self): # -> bool:
        """
        Writable attribute to disable drawing background
        color and outside border
        """
        ...
    
    @no_background.setter
    def no_background(self, value: bool): # -> None:
        ...
    
    @property
    def no_saved_settings(self): # -> bool:
        """
        Writable attribute to never load/save settings in .ini file
        """
        ...
    
    @no_saved_settings.setter
    def no_saved_settings(self, value: bool): # -> None:
        ...
    
    @property
    def no_mouse_inputs(self): # -> bool:
        """
        Writable attribute to disable mouse input event catching of the window.
        Events such as clicked, hovering, etc will be passed to items behind the
        window.
        """
        ...
    
    @no_mouse_inputs.setter
    def no_mouse_inputs(self, value: bool): # -> None:
        ...
    
    @property
    def no_keyboard_inputs(self): # -> bool:
        """
        Writable attribute to disable keyboard manipulation (scroll).
        The window will not take focus of the keyboard.
        Does not affect items inside the window.
        """
        ...
    
    @no_keyboard_inputs.setter
    def no_keyboard_inputs(self, value: bool): # -> None:
        ...
    
    @property
    def menubar(self): # -> bool:
        """
        Writable attribute to indicate whether the window has a menu bar.

        There will be menubar if either the user has asked for it,
        or there is a menubar child.
        """
        ...
    
    @menubar.setter
    def menubar(self, value: bool): # -> None:
        ...
    
    @property
    def horizontal_scrollbar(self): # -> bool:
        """
        Writable attribute to enable having an horizontal scrollbar
        """
        ...
    
    @horizontal_scrollbar.setter
    def horizontal_scrollbar(self, value: bool): # -> None:
        ...
    
    @property
    def no_focus_on_appearing(self): # -> bool:
        """
        Writable attribute to indicate when the windows moves from
        an un-shown to a shown item shouldn't be made automatically
        focused
        """
        ...
    
    @no_focus_on_appearing.setter
    def no_focus_on_appearing(self, value: bool): # -> None:
        ...
    
    @property
    def no_bring_to_front_on_focus(self): # -> bool:
        """
        Writable attribute to indicate when the window takes focus (click on it, etc)
        it shouldn't be shown in front of other windows
        """
        ...
    
    @no_bring_to_front_on_focus.setter
    def no_bring_to_front_on_focus(self, value: bool): # -> None:
        ...
    
    @property
    def always_show_vertical_scrollvar(self): # -> bool:
        """
        Writable attribute to tell to always show a vertical scrollbar
        even when the size does not require it
        """
        ...
    
    @always_show_vertical_scrollvar.setter
    def always_show_vertical_scrollvar(self, value: bool): # -> None:
        ...
    
    @property
    def always_show_horizontal_scrollvar(self): # -> bool:
        """
        Writable attribute to tell to always show a horizontal scrollbar
        even when the size does not require it (only if horizontal scrollbar
        are enabled)
        """
        ...
    
    @always_show_horizontal_scrollvar.setter
    def always_show_horizontal_scrollvar(self, value: bool): # -> None:
        ...
    
    @property
    def unsaved_document(self): # -> bool:
        """
        Writable attribute to display a dot next to the title, as if the window
        contains unsaved changes.
        """
        ...
    
    @unsaved_document.setter
    def unsaved_document(self, value: bool): # -> None:
        ...
    
    @property
    def disallow_docking(self): # -> bool:
        """
        Writable attribute to disable docking for the window
        """
        ...
    
    @disallow_docking.setter
    def disallow_docking(self, value: bool): # -> None:
        ...
    
    @property
    def no_open_over_existing_popup(self): # -> bint:
        """
        Writable attribute for modal and popup windows to prevent them from
        showing if there is already an existing popup/modal window
        """
        ...
    
    @no_open_over_existing_popup.setter
    def no_open_over_existing_popup(self, value: bool): # -> None:
        ...
    
    @property
    def modal(self): # -> bint:
        """
        Writable attribute to indicate the window is a modal window.
        Modal windows are similar to popup windows, but they have a close
        button and are not closed by clicking outside.
        Clicking has no effect of items outside the modal window until it is closed.
        """
        ...
    
    @modal.setter
    def modal(self, value: bool): # -> None:
        ...
    
    @property
    def popup(self): # -> bint:
        """
        Writable attribute to indicate the window is a popup window.
        Popup windows are centered (unless a pos is set), do not have a
        close button, and are closed when they lose focus (clicking outside the
        window).
        """
        ...
    
    @popup.setter
    def popup(self, value: bool): # -> None:
        ...
    
    @property
    def has_close_button(self): # -> bint | bool:
        """
        Writable attribute to indicate the window has a close button.
        Has effect only for normal and modal windows.
        """
        ...
    
    @has_close_button.setter
    def has_close_button(self, value: bool): # -> None:
        ...
    
    @property
    def collapsed(self): # -> bool:
        """
        Writable attribute to collapse (~minimize) or uncollapse the window
        """
        ...
    
    @collapsed.setter
    def collapsed(self, value: bool): # -> None:
        ...
    
    @property
    def on_close(self): # -> Callback:
        """
        Callback to call when the window is closed.
        Note closing the window does not destroy or unattach the item.
        Instead it is switched to a show=False state.
        """
        ...
    
    @on_close.setter
    def on_close(self, value): # -> None:
        ...
    
    @property
    def primary(self): # -> bint:
        """
        Writable attribute: Indicate if the window is the primary window.
        There is maximum one primary window. The primary window covers the whole
        viewport and can be used to draw on the background.
        It is equivalent to setting:
        no_bring_to_front_on_focus
        no_saved_settings
        no_resize
        no_collapse
        no_title_bar
        and running item.focused = True on all the other windows
        """
        ...
    
    @primary.setter
    def primary(self, value: bool): # -> None:
        ...
    
    @property
    def min_size(self): # -> object:
        """
        Writable attribute to indicate the minimum window size
        """
        ...
    
    @min_size.setter
    def min_size(self, value): # -> None:
        ...
    
    @property
    def max_size(self): # -> object:
        """
        Writable attribute to indicate the maximum window size
        """
        ...
    
    @max_size.setter
    def max_size(self, value): # -> None:
        ...
    


class Texture(baseItem):
    def __delalloc__(self): # -> None:
        ...
    
    def configure(self, *args, **kwargs): # -> None:
        ...
    
    @property
    def hint_dynamic(self): # -> bint:
        """
        Hint for texture placement that
        the texture will be updated very
        frequently.
        """
        ...
    
    @hint_dynamic.setter
    def hint_dynamic(self, value: bool): # -> None:
        ...
    
    @property
    def nearest_neighbor_upsampling(self): # -> Literal[True, 0]:
        """
        Whether to use nearest neighbor interpolation
        instead of bilinear interpolation when upscaling
        the texture. Must be set before set_value.
        """
        ...
    
    @nearest_neighbor_upsampling.setter
    def nearest_neighbor_upsampling(self, value: bool): # -> None:
        ...
    
    @property
    def width(self): # -> int:
        """ Width of the current texture content """
        ...
    
    @property
    def height(self): # -> int:
        """ Height of the current texture content """
        ...
    
    @property
    def num_chans(self): # -> int:
        """ Number of channels of the current texture content """
        ...
    
    def set_value(self, value): # -> None:
        """
        Pass an array as texture data.
        The currently native formats are:
        - data type: uint8 or float32.
            Anything else will be converted to float32
            float32 data must be normalized between 0 and 1.
        - number of channels: 1 (R), 2 (RG), 3 (RGB), 4 (RGBA)

        In the case of single channel textures, during rendering, R is
        duplicated on G and B, thus the texture is displayed as gray,
        not red.

        If set_value is called on a texture which already
        has content, the previous allocation will be reused
        if the size, type and number of channels is identical.

        The data is uploaded right away during set_value,
        thus the call is not instantaneous.
        The data can be discarded after set_value.

        If you change the data of a texture, you don't
        need to bind it again to the objects it is
        bound. The objects will automatically take
        the updated texture.
        """
        ...
    


def get_system_fonts(): # -> list:
    """
    Returns a list of available fonts
    """
    ...

class Font(baseItem):
    @property
    def texture(self): # -> FontTexture:
        ...
    
    @property
    def size(self): # -> float:
        """Readonly attribute: native height of characters"""
        ...
    
    @property
    def scale(self): # -> float:
        ...
    
    @scale.setter
    def scale(self, value: float): # -> None:
        ...
    


class FontTexture(baseItem):
    """
    Packs one or several fonts into
    a texture for internal use by ImGui.
    """
    def __delalloc__(self): # -> None:
        ...
    
    def add_font_file(self, path: str, size: float = ..., index_in_file: int = ..., density_scale: float = ..., align_to_pixel: bool = ...): # -> None:
        """
        Prepare the target font file to be added to the FontTexture

        path: path to the input font file (ttf, otf, etc).
        size: Target pixel size at which the font will be rendered by default.
        index_in_file: index of the target font in the font file.
        density_scale: rasterizer oversampling to better render when
            the font scale is not 1.
        align_to_pixel: For sharp fonts, will prevent blur by
            aligning font rendering to the pixel. The spacing
            between characters might appear slightly odd as
            a result, so don't enable when not needed.
        """
        ...
    
    @property
    def built(self): # -> bint:
        ...
    
    @property
    def texture(self): # -> Texture:
        """
        Readonly texture containing the font data.
        build() must be called first
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, index):
        ...
    
    def build(self): # -> None:
        """
        Packs all the fonts appended with add_font_file
        into a readonly texture. 
        """
        ...
    


class baseTheme(baseItem):
    """
    Base theme element. Contains a set of theme elements
    to apply for a given category (color, style)/(imgui/implot/imnode)
    """
    def configure(self, **kwargs): # -> None:
        ...
    
    @property
    def enabled(self): # -> bint:
        ...
    
    @enabled.setter
    def enabled(self, value: bool): # -> None:
        ...
    


class PlotAxisConfig(baseItem):
    @property
    def enabled(self): # -> bint:
        """
        Whether elements using this axis should
        be drawn.
        """
        ...
    
    @enabled.setter
    def enabled(self, value: bool): # -> None:
        ...
    
    @property
    def scale(self): # -> AxisScale:
        """
        Current AxisScale.
        Default is AxisScale.linear
        """
        ...
    
    @scale.setter
    def scale(self, value: AxisScale): # -> None:
        ...
    
    @property
    def min(self): # -> double:
        """
        Current minimum of the range displayed.
        Do not set max <= min. Set invert to change
        the axis order.
        """
        ...
    
    @min.setter
    def min(self, value: float): # -> None:
        ...
    
    @property
    def max(self): # -> double:
        """
        Current maximum of the range displayed.
        Do not set max <= min. Set invert to change
        the axis order.
        """
        ...
    
    @max.setter
    def max(self, value: float): # -> None:
        ...
    
    @property
    def constraint_min(self): # -> double:
        """
        Constraint on the minimum value
        of min.
        """
        ...
    
    @constraint_min.setter
    def constraint_min(self, value: float): # -> None:
        ...
    
    @property
    def constraint_max(self): # -> double:
        """
        Constraint on the maximum value
        of max.
        """
        ...
    
    @constraint_max.setter
    def constraint_max(self, value: float): # -> None:
        ...
    
    @property
    def zoom_min(self): # -> double:
        """
        Constraint on the minimum value
        of the zoom
        """
        ...
    
    @zoom_min.setter
    def zoom_min(self, value: float): # -> None:
        ...
    
    @property
    def zoom_max(self): # -> double:
        """
        Constraint on the maximum value
        of the zoom
        """
        ...
    
    @zoom_max.setter
    def zoom_max(self, value: float): # -> None:
        ...
    
    @property
    def no_label(self): # -> bool:
        """
        Writable attribute to not render the axis label
        """
        ...
    
    @no_label.setter
    def no_label(self, value: bool): # -> None:
        ...
    
    @property
    def no_gridlines(self): # -> bool:
        """
        Writable attribute to not render grid lines
        """
        ...
    
    @no_gridlines.setter
    def no_gridlines(self, value: bool): # -> None:
        ...
    
    @property
    def no_tick_marks(self): # -> bool:
        """
        Writable attribute to not render tick marks
        """
        ...
    
    @no_tick_marks.setter
    def no_tick_marks(self, value: bool): # -> None:
        ...
    
    @property
    def no_tick_labels(self): # -> bool:
        """
        Writable attribute to not render tick labels
        """
        ...
    
    @no_tick_labels.setter
    def no_tick_labels(self, value: bool): # -> None:
        ...
    
    @property
    def no_initial_fit(self): # -> bool:
        """
        Writable attribute to disable fitting the extent
        of the axis to the data on the first frame.
        """
        ...
    
    @no_initial_fit.setter
    def no_initial_fit(self, value: bool): # -> None:
        ...
    
    @property
    def no_menus(self): # -> bool:
        """
        Writable attribute to prevent right-click to
        open context menus.
        """
        ...
    
    @no_menus.setter
    def no_menus(self, value: bool): # -> None:
        ...
    
    @property
    def no_side_switch(self): # -> bool:
        """
        Writable attribute to prevent the user from switching
        the axis by dragging it.
        """
        ...
    
    @no_side_switch.setter
    def no_side_switch(self, value: bool): # -> None:
        ...
    
    @property
    def no_highlight(self): # -> bool:
        """
        Writable attribute to not highlight the axis background
        when hovered or held
        """
        ...
    
    @no_highlight.setter
    def no_highlight(self, value: bool): # -> None:
        ...
    
    @property
    def opposite(self): # -> bool:
        """
        Writable attribute to render ticks and labels on
        the opposite side.
        """
        ...
    
    @opposite.setter
    def opposite(self, value: bool): # -> None:
        ...
    
    @property
    def foreground_grid(self): # -> bool:
        """
        Writable attribute to render gridlines on top of
        the data rather than behind.
        """
        ...
    
    @foreground_grid.setter
    def foreground_grid(self, value: bool): # -> None:
        ...
    
    @property
    def invert(self): # -> bool:
        """
        Writable attribute to invert the values of the axis
        """
        ...
    
    @invert.setter
    def invert(self, value: bool): # -> None:
        ...
    
    @property
    def auto_fit(self): # -> bool:
        """
        Writable attribute to force the axis to fit its range
        to the data every frame.
        """
        ...
    
    @auto_fit.setter
    def auto_fit(self, value: bool): # -> None:
        ...
    
    @property
    def restrict_fit_to_range(self): # -> bool:
        """
        Writable attribute to ignore points that are outside
        the visible region of the opposite axis when fitting
        this axis.
        """
        ...
    
    @restrict_fit_to_range.setter
    def restrict_fit_to_range(self, value: bool): # -> None:
        ...
    
    @property
    def pan_stretch(self): # -> bool:
        """
        Writable attribute that when set, if panning in a locked or
        constrained state, will cause the axis to stretch
        if possible.
        """
        ...
    
    @pan_stretch.setter
    def pan_stretch(self, value: bool): # -> None:
        ...
    
    @property
    def lock_min(self): # -> bool:
        """
        Writable attribute to lock the axis minimum value
        when panning/zooming
        """
        ...
    
    @lock_min.setter
    def lock_min(self, value: bool): # -> None:
        ...
    
    @property
    def lock_max(self): # -> bool:
        """
        Writable attribute to lock the axis maximum value
        when panning/zooming
        """
        ...
    
    @lock_max.setter
    def lock_max(self, value: bool): # -> None:
        ...
    
    @property
    def hovered(self): # -> bint:
        """
        Readonly attribute: Is the mouse inside the axis label area
        """
        ...
    
    @property
    def clicked(self): # -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        """
        ...
    
    @property
    def mouse_coord(self): # -> double:
        """
        Readonly attribute:
        The last estimated mouse position in plot space
        for this axis.
        Beware not to assign the same instance of
        PlotAxisConfig to several axes if you plan on using
        this.
        The mouse position is updated everytime the plot is
        drawn and the axis is enabled.
        """
        ...
    
    @property
    def handlers(self): # -> list:
        """
        Writable attribute: bound handlers for the axis.
        Only visible, hovered and clicked handlers are compatible.
        """
        ...
    
    @handlers.setter
    def handlers(self, value): # -> None:
        ...
    
    def fit(self): # -> None:
        """
        Request for a fit of min/max to the data the next time the plot is drawn
        """
        ...
    
    @property
    def label(self): # -> str:
        """
        Writable attribute: axis name
        """
        ...
    
    @label.setter
    def label(self, value): # -> None:
        ...
    
    @property
    def format(self): # -> str:
        """
        Writable attribute: format string to display axis values
        """
        ...
    
    @format.setter
    def format(self, value): # -> None:
        ...
    
    @property
    def labels(self): # -> list[str]:
        """
        Writable attribute: array of strings to display as labels
        """
        ...
    
    @labels.setter
    def labels(self, value): # -> None:
        ...
    
    @property
    def labels_coord(self): # -> list:
        """
        Writable attribute: coordinate for each label in labels at
        which to display the labels
        """
        ...
    
    @labels_coord.setter
    def labels_coord(self, value): # -> None:
        ...
    


class PlotLegendConfig(baseItem):
    '''
    # Probable doesn't work. Use instead plot no_legend
    @property
    def show(self):
        """
        Whether the legend is shown or hidden
        """
        cdef unique_lock[recursive_mutex] m
        lock_gil_friendly(m, self.mutex)
        return self._show

    @show.setter
    def show(self, bint value):
        cdef unique_lock[recursive_mutex] m
        lock_gil_friendly(m, self.mutex)
        if not(value) and self._show:
            self.set_hidden_and_propagate_to_siblings_no_handlers()
        self._show = value
    '''
    @property
    def location(self): # -> LegendLocation:
        """
        Position of the legend.
        Default is LegendLocation.northwest
        """
        ...
    
    @location.setter
    def location(self, value: LegendLocation): # -> None:
        ...
    
    @property
    def no_buttons(self): # -> bool:
        """
        Writable attribute to prevent legend icons
        to function as hide/show buttons
        """
        ...
    
    @no_buttons.setter
    def no_buttons(self, value: bool): # -> None:
        ...
    
    @property
    def no_highlight_item(self): # -> bool:
        """
        Writable attribute to disable highlighting plot items
        when their legend entry is hovered
        """
        ...
    
    @no_highlight_item.setter
    def no_highlight_item(self, value: bool): # -> None:
        ...
    
    @property
    def no_highlight_axis(self): # -> bool:
        """
        Writable attribute to disable highlighting axes
        when their legend entry is hovered
        (only relevant if x/y-axis count > 1)
        """
        ...
    
    @no_highlight_axis.setter
    def no_highlight_axis(self, value: bool): # -> None:
        ...
    
    @property
    def no_menus(self): # -> bool:
        """
        Writable attribute to disable right-clicking
        to open context menus.
        """
        ...
    
    @no_menus.setter
    def no_menus(self, value: bool): # -> None:
        ...
    
    @property
    def outside(self): # -> bool:
        """
        Writable attribute to render the legend outside
        of the plot area
        """
        ...
    
    @outside.setter
    def outside(self, value: bool): # -> None:
        ...
    
    @property
    def horizontal(self): # -> bool:
        """
        Writable attribute to display the legend entries
        horizontally rather than vertically
        """
        ...
    
    @horizontal.setter
    def horizontal(self, value: bool): # -> None:
        ...
    
    @property
    def sorted(self): # -> bool:
        """
        Writable attribute to display the legend entries
        in alphabetical order
        """
        ...
    
    @sorted.setter
    def sorted(self, value: bool): # -> None:
        ...
    


class Plot(uiItem):
    """
    Plot. Can have Plot elements as child.

    By default the axes X1 and Y1 are enabled,
    but other can be enabled, up to X3 and Y3.
    For instance:
    my_plot.X2.enabled = True

    By default, the legend and axes have reserved space.
    They can have their own handlers that can react to
    when they are hovered by the mouse or clicked.

    The states of the plot relate to the rendering area (excluding
    the legend, padding and axes). Thus if you want to react
    to mouse event inside the plot area (for example implementing
    clicking an curve), you can do it with using handlers bound
    to the plot (+ some logic in your callbacks). 
    """
    @property
    def X1(self): # -> PlotAxisConfig:
        ...
    
    @X1.setter
    def X1(self, value: PlotAxisConfig): # -> None:
        ...
    
    @property
    def X2(self): # -> PlotAxisConfig:
        ...
    
    @X2.setter
    def X2(self, value: PlotAxisConfig): # -> None:
        ...
    
    @property
    def X3(self): # -> PlotAxisConfig:
        ...
    
    @X3.setter
    def X3(self, value: PlotAxisConfig): # -> None:
        ...
    
    @property
    def Y1(self): # -> PlotAxisConfig:
        ...
    
    @Y1.setter
    def Y1(self, value: PlotAxisConfig): # -> None:
        ...
    
    @property
    def Y2(self): # -> PlotAxisConfig:
        ...
    
    @Y2.setter
    def Y2(self, value: PlotAxisConfig): # -> None:
        ...
    
    @property
    def Y3(self): # -> PlotAxisConfig:
        ...
    
    @Y3.setter
    def Y3(self, value: PlotAxisConfig): # -> None:
        ...
    
    @property
    def axes(self): # -> list[PlotAxisConfig]:
        """
        Helper read-only property to retrieve the 6 axes
        in an array [X1, X2, X3, Y1, Y2, Y3]
        """
        ...
    
    @property
    def legend_config(self): # -> PlotLegendConfig:
        ...
    
    @legend_config.setter
    def legend_config(self, value: PlotLegendConfig): # -> None:
        ...
    
    @property
    def content_pos(self): # -> object:
        """
        Readable attribute indicating the top left starting
        position of the plot content in viewport coordinates.

        The size of the plot content area is available with
        content_size_avail.
        """
        ...
    
    @property
    def pan_button(self): # -> int:
        """
        Button that when held enables to navigate inside the plot
        Default is the left mouse button.
        """
        ...
    
    @pan_button.setter
    def pan_button(self, button: int): # -> None:
        ...
    
    @property
    def pan_mod(self): # -> int:
        """
        Modifier combination (shift/ctrl/alt/super) that must be
        pressed for pan_button to have effect.
        Default is no modifier.
        """
        ...
    
    @pan_mod.setter
    def pan_mod(self, modifier: int): # -> None:
        ...
    
    @property
    def fit_button(self): # -> int:
        """
        Button that must be double-clicked to initiate
        a fit of the axes to the displayed data.
        Default is the left mouse button.
        """
        ...
    
    @fit_button.setter
    def fit_button(self, button: int): # -> None:
        ...
    
    @property
    def menu_button(self): # -> int:
        """
        Button that opens context menus
        (if enabled) when clicked.
        Default is the right mouse button.
        """
        ...
    
    @menu_button.setter
    def menu_button(self, button: int): # -> None:
        ...
    
    @property
    def zoom_mod(self): # -> int:
        """
        Modifier combination (shift/ctrl/alt/super) that
        must be hold for the mouse wheel to trigger a zoom
        of the plot.
        Default is no modifier.
        """
        ...
    
    @zoom_mod.setter
    def zoom_mod(self, modifier: int): # -> None:
        ...
    
    @property
    def zoom_rate(self): # -> float:
        """
        Zoom rate for scroll (e.g. 0.1 = 10% plot range every
        scroll click);
        make negative to invert.
        Default is 0.1
        """
        ...
    
    @zoom_rate.setter
    def zoom_rate(self, value: float): # -> None:
        ...
    
    @property
    def use_local_time(self): # -> bint:
        """
        If set, axis labels will be formatted for the system
        timezone when ImPlotAxisFlag_Time is enabled.
        Default is False.
        """
        ...
    
    @use_local_time.setter
    def use_local_time(self, value: bool): # -> None:
        ...
    
    @property
    def use_ISO8601(self): # -> bint:
        """
        If set, dates will be formatted according to ISO 8601
        where applicable (e.g. YYYY-MM-DD, YYYY-MM,
        --MM-DD, etc.)
        Default is False.
        """
        ...
    
    @use_ISO8601.setter
    def use_ISO8601(self, value: bool): # -> None:
        ...
    
    @property
    def use_24hour_clock(self): # -> bint:
        """
        If set, times will be formatted using a 24 hour clock.
        Default is False
        """
        ...
    
    @use_24hour_clock.setter
    def use_24hour_clock(self, value: bool): # -> None:
        ...
    
    @property
    def no_title(self): # -> bool:
        """
        Writable attribute to disable the display of the
        plot title
        """
        ...
    
    @no_title.setter
    def no_title(self, value: bool): # -> None:
        ...
    
    @property
    def no_menus(self): # -> bool:
        """
        Writable attribute to disable the user interactions
        to open the context menus
        """
        ...
    
    @no_menus.setter
    def no_menus(self, value: bool): # -> None:
        ...
    
    @property
    def no_mouse_pos(self): # -> bool:
        """
        Writable attribute to disable the display of the
        mouse position
        """
        ...
    
    @no_mouse_pos.setter
    def no_mouse_pos(self, value: bool): # -> None:
        ...
    
    @property
    def crosshairs(self): # -> bool:
        """
        Writable attribute to replace the default mouse
        cursor by a crosshair when hovered
        """
        ...
    
    @crosshairs.setter
    def crosshairs(self, value: bool): # -> None:
        ...
    
    @property
    def equal_aspects(self): # -> bool:
        """
        Writable attribute to constrain x/y axes
        pairs to have the same units/pixels
        """
        ...
    
    @equal_aspects.setter
    def equal_aspects(self, value: bool): # -> None:
        ...
    
    @property
    def no_inputs(self): # -> bool:
        """
        Writable attribute to disable user interactions with
        the plot.
        """
        ...
    
    @no_inputs.setter
    def no_inputs(self, value: bool): # -> None:
        ...
    
    @property
    def no_frame(self): # -> bool:
        """
        Writable attribute to disable the drawing of the
        imgui frame.
        """
        ...
    
    @no_frame.setter
    def no_frame(self, value: bool): # -> None:
        ...
    
    @property
    def no_legend(self): # -> bool:
        """
        Writable attribute to disable the display of the
        legend
        """
        ...
    
    @no_legend.setter
    def no_legend(self, value: bool): # -> None:
        ...
    


class plotElement(baseItem):
    """
    Base class for plot children.
    """
    @property
    def show(self): # -> bint:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        """
        ...
    
    @show.setter
    def show(self, value: bool): # -> None:
        ...
    
    @property
    def axes(self): # -> tuple[int, int]:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        """
        ...
    
    @axes.setter
    def axes(self, value): # -> None:
        ...
    
    @property
    def label(self): # -> str:
        """
        Writable attribute: label assigned to the element
        """
        ...
    
    @label.setter
    def label(self, value: str): # -> None:
        ...
    
    @property
    def theme(self): # -> baseTheme:
        """
        Writable attribute: theme for the legend and plot
        """
        ...
    
    @theme.setter
    def theme(self, value: baseTheme): # -> None:
        ...
    


class plotElementWithLegend(plotElement):
    """
    Base class for plot children with a legend.

    Children of plot elements are rendered on a legend
    popup entry that gets shown on a right click (by default).
    """
    @property
    def no_legend(self): # -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        """
        ...
    
    @no_legend.setter
    def no_legend(self, value: bool): # -> None:
        ...
    
    @property
    def ignore_fit(self): # -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        """
        ...
    
    @ignore_fit.setter
    def ignore_fit(self, value: bool): # -> None:
        ...
    
    @property
    def enabled(self): # -> bint:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        """
        ...
    
    @enabled.setter
    def enabled(self, value: bool): # -> None:
        ...
    
    @property
    def font(self): # -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        """
        ...
    
    @font.setter
    def font(self, value: Font): # -> None:
        ...
    
    @property
    def legend_button(self): # -> int:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        """
        ...
    
    @legend_button.setter
    def legend_button(self, button: int): # -> None:
        ...
    
    @property
    def legend_handlers(self): # -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        """
        ...
    
    @legend_handlers.setter
    def legend_handlers(self, value): # -> None:
        ...
    
    @property
    def legend_hovered(self): # -> bint:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        """
        ...
    


class plotElementXY(plotElementWithLegend):
    @property
    def X(self): # -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        """
        ...
    
    @X.setter
    def X(self, value): # -> None:
        ...
    
    @property
    def Y(self): # -> ndarray:
        ...
    
    @Y.setter
    def Y(self, value): # -> None:
        ...
    


class PlotLine(plotElementXY):
    @property
    def segments(self): # -> bool:
        """
        Plot segments rather than a full line
        """
        ...
    
    @segments.setter
    def segments(self, value: bool): # -> None:
        ...
    
    @property
    def loop(self): # -> bool:
        """
        Connect the first and last points
        """
        ...
    
    @loop.setter
    def loop(self, value: bool): # -> None:
        ...
    
    @property
    def skip_nan(self): # -> bool:
        """
        A NaN data point will be ignored instead of
        being rendered as missing data.
        """
        ...
    
    @skip_nan.setter
    def skip_nan(self, value: bool): # -> None:
        ...
    
    @property
    def no_clip(self): # -> bool:
        """
        Markers (if displayed) on the edge of a plot will not be clipped.
        """
        ...
    
    @no_clip.setter
    def no_clip(self, value: bool): # -> None:
        ...
    
    @property
    def shaded(self): # -> bool:
        """
        A filled region between the line and horizontal
        origin will be rendered.
        """
        ...
    
    @shaded.setter
    def shaded(self, value: bool): # -> None:
        ...
    


class plotElementXYY(plotElementWithLegend):
    @property
    def X(self): # -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        """
        ...
    
    @X.setter
    def X(self, value): # -> None:
        ...
    
    @property
    def Y1(self): # -> ndarray:
        ...
    
    @Y1.setter
    def Y1(self, value): # -> None:
        ...
    
    @property
    def Y2(self): # -> ndarray:
        ...
    
    @Y2.setter
    def Y2(self, value): # -> None:
        ...
    


class PlotShadedLine(plotElementXYY):
    ...


class PlotStems(plotElementXY):
    @property
    def horizontal(self): # -> bool:
        """
        Stems will be rendered horizontally
        """
        ...
    
    @horizontal.setter
    def horizontal(self, value: bool): # -> None:
        ...
    


class PlotBars(plotElementXY):
    @property
    def weight(self): # -> double:
        """
        bar_size. TODO better document
        """
        ...
    
    @weight.setter
    def weight(self, value: float): # -> None:
        ...
    
    @property
    def horizontal(self): # -> bool:
        """
        Bars will be rendered horizontally
        """
        ...
    
    @horizontal.setter
    def horizontal(self, value: bool): # -> None:
        ...
    


class PlotStairs(plotElementXY):
    @property
    def pre_step(self): # -> bool:
        """
        The y value is continued constantly to the left
        from every x position, i.e. the interval
        (x[i-1], x[i]] has the value y[i].
        """
        ...
    
    @pre_step.setter
    def pre_step(self, value: bool): # -> None:
        ...
    
    @property
    def shaded(self): # -> bool:
        """
        a filled region between the stairs and horizontal
        origin will be rendered; use PlotShadedLine for
        more advanced cases.
        """
        ...
    
    @shaded.setter
    def shaded(self, value: bool): # -> None:
        ...
    


class plotElementX(plotElementWithLegend):
    @property
    def X(self): # -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        """
        ...
    
    @X.setter
    def X(self, value): # -> None:
        ...
    


class PlotInfLines(plotElementX):
    """
    Draw vertical (or horizontal) infinite lines at
    the passed coordinates
    """
    @property
    def horizontal(self): # -> bool:
        """
        Plot horizontal lines rather than plots
        """
        ...
    
    @horizontal.setter
    def horizontal(self, value: bool): # -> None:
        ...
    


class PlotScatter(plotElementXY):
    @property
    def no_clip(self): # -> bool:
        """
        Markers on the edge of a plot will not be clipped
        """
        ...
    
    @no_clip.setter
    def no_clip(self, value: bool): # -> None:
        ...
    


class DrawInPlot(plotElementWithLegend):
    """
    A plot element that enables to insert Draw* items
    inside a plot in plot coordinates.

    defaults to no_legend = True
    """
    @property
    def ignore_fit(self): # -> bint:
        """
        Writable attribute to make this element
        be ignored during plot fits
        """
        ...
    
    @ignore_fit.setter
    def ignore_fit(self, value: bool): # -> None:
        ...
    


def color_as_int(val): # -> int:
    ...

def color_as_ints(val): # -> tuple[int, int, int, int]:
    ...

def color_as_floats(val): # -> tuple[float, float, float, float]:
    ...

class mouse_cursor(IntEnum):
    CursorNone = ...
    CursorArrow = ...
    CursorTextInput = ...
    ResizeAll = ...
    ResizeNS = ...
    ResizeEW = ...
    ResizeNESW = ...
    ResizeNWSE = ...
    Hand = ...
    NotAllowed = ...


CursorNone: mouse_cursor = ...
CursorArrow: mouse_cursor = ...
CursorTextInput: mouse_cursor = ...
ResizeAll: mouse_cursor = ...
ResizeNS: mouse_cursor = ...
ResizeEW: mouse_cursor = ...
ResizeNESW: mouse_cursor = ...
ResizeNWSE: mouse_cursor = ...
Hand: mouse_cursor = ...
NotAllowed: mouse_cursor = ...
class positioning(IntEnum):
    DEFAULT = ...
    REL_DEFAULT = ...
    REL_PARENT = ...
    REL_WINDOW = ...
    REL_VIEWPORT = ...


DEFAULT: positioning = ...
REL_DEFAULT: positioning = ...
REL_PARENT: positioning = ...
REL_WINDOW: positioning = ...
REL_VIEWPORT: positioning = ...
class alignment(IntEnum):
    LEFT = ...
    TOP = ...
    RIGHT = ...
    BOTTOM = ...
    CENTER = ...
    JUSTIFIED = ...
    MANUAL = ...


LEFT: alignment = ...
TOP: alignment = ...
RIGHT: alignment = ...
BOTTOM: alignment = ...
CENTER: alignment = ...
JUSTIFIED: alignment = ...
MANUAL: alignment = ...
class theme_enablers(IntEnum):
    t_enabled_any = ...
    t_enabled_False = ...
    t_enabled_True = ...
    t_discarded = ...


t_enabled_any: theme_enablers = ...
t_enabled_False: theme_enablers = ...
t_enabled_True: theme_enablers = ...
t_discarded: theme_enablers = ...
class theme_categories(IntEnum):
    t_any = ...
    t_simpleplot = ...
    t_button = ...
    t_combo = ...
    t_checkbox = ...
    t_slider = ...
    t_listbox = ...
    t_radiobutton = ...
    t_inputtext = ...
    t_inputvalue = ...
    t_text = ...
    t_selectable = ...
    t_tab = ...
    t_tabbar = ...
    t_tabbutton = ...
    t_menuitem = ...
    t_progressbar = ...
    t_image = ...
    t_imagebutton = ...
    t_menubar = ...
    t_menu = ...
    t_tooltip = ...
    t_layout = ...
    t_treenode = ...
    t_collapsingheader = ...
    t_child = ...
    t_colorbutton = ...
    t_coloredit = ...
    t_colorpicker = ...
    t_window = ...
    t_plot = ...


t_any: theme_categories = ...
t_simpleplot: theme_categories = ...
t_button: theme_categories = ...
t_combo: theme_categories = ...
t_checkbox: theme_categories = ...
t_slider: theme_categories = ...
t_listbox: theme_categories = ...
t_radiobutton: theme_categories = ...
t_inputtext: theme_categories = ...
t_inputvalue: theme_categories = ...
t_text: theme_categories = ...
t_selectable: theme_categories = ...
t_tab: theme_categories = ...
t_tabbar: theme_categories = ...
t_tabbutton: theme_categories = ...
t_menuitem: theme_categories = ...
t_progressbar: theme_categories = ...
t_image: theme_categories = ...
t_imagebutton: theme_categories = ...
t_menubar: theme_categories = ...
t_menu: theme_categories = ...
t_tooltip: theme_categories = ...
t_layout: theme_categories = ...
t_treenode: theme_categories = ...
t_collapsingheader: theme_categories = ...
t_child: theme_categories = ...
t_colorbutton: theme_categories = ...
t_coloredit: theme_categories = ...
t_colorpicker: theme_categories = ...
t_window: theme_categories = ...
t_plot: theme_categories = ...
class AxisScale(IntEnum):
    linear = ...
    time = ...
    log10 = ...
    symlog = ...


linear: AxisScale = ...
time: AxisScale = ...
log10: AxisScale = ...
symlog: AxisScale = ...
class Axis(IntEnum):
    X1 = ...
    X2 = ...
    X3 = ...
    Y1 = ...
    Y2 = ...
    Y3 = ...


X1: Axis = ...
X2: Axis = ...
X3: Axis = ...
Y1: Axis = ...
Y2: Axis = ...
Y3: Axis = ...
class LegendLocation(IntEnum):
    center = ...
    north = ...
    south = ...
    west = ...
    east = ...
    northwest = ...
    northeast = ...
    southwest = ...
    southeast = ...


center: LegendLocation = ...
north: LegendLocation = ...
south: LegendLocation = ...
west: LegendLocation = ...
east: LegendLocation = ...
northwest: LegendLocation = ...
northeast: LegendLocation = ...
southwest: LegendLocation = ...
southeast: LegendLocation = ...
