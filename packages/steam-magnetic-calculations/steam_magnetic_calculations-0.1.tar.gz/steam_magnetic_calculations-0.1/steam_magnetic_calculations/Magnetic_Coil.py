import math
import numpy as np
import time
from numba import njit, prange


@njit(parallel=True, fastmath=True)
def calculateMagneticField_Numba(xS, yS, iS, idx_sources, x0s, y0s):
    '''
    Further optimized calculation of the magnetic field using Biot-Savart law,
    with an additional loop for the second dimension of B.
    '''

    # Constants
    veryLow = 1E-12
    mu0_over_2pi = 2e-7

    # Convert inputs to numpy arrays if not already
    n_points = len(x0s)
    n_components = iS.shape[1]  # Second dimension of iS

    # Allocate space for results
    Bx = np.zeros((n_points, n_components), dtype=np.float32)
    By = np.zeros((n_points, n_components), dtype=np.float32)


    # Loop over each point where we calculate the magnetic field
    for i in prange(n_points):
        # Precompute the target coordinates
        x0, y0 = x0s[i], y0s[i]
        # Accumulate magnetic field components for each source
        for p in range(len(idx_sources)):
            j = idx_sources[p]
            dx, dy = x0 - xS[j], y0 - yS[j]
            distance_sq = dx * dx + dy * dy + veryLow
            inv_distance = 1.0 / distance_sq

            # Additional loop for each component of iS
            for k in range(n_components):
                Bx[i, k] -= iS[j, k] * dy * inv_distance
                By[i, k] += iS[j, k] * dx * inv_distance

    # Scale by constant
    Bx *= mu0_over_2pi
    By *= mu0_over_2pi

    # Calculate the magnitude of the magnetic field outside the loop for each point
    B = np.sqrt(Bx ** 2 + By ** 2)

    return Bx, By, B


class MagneticCoil:
    '''
        Class of magnetic coil
    '''

    def __init__(self, xS = [], yS = [], iS = []):
        self.xS = xS
        self.yS = yS
        self.iS = iS


    def setStrandPositions(self, xS, yS, iS):
        self.xS, self.yS, self.iS = xS, yS, iS


    def calculateMagneticField(self, x0s: list, y0s: list) -> list:
        '''
            **Calculates magnetic field generated by the coil in the points (x0s,y0s) using Biot-Savart law**

            Returns X and Y components of the magnetic field, and its absolute value, for each point [T].

            :param x0s: List of X position of the point where the magnetic field is calculated [m]
            :type x0s: list
            :param y0s: List of Y position of the point where the magnetic field is calculated [m]
            :type y0s: list

            :return: list
        '''
        x0s = np.array(x0s, dtype=np.float64)
        y0s = np.array(y0s, dtype=np.float64)
        xS = np.array(self.xS, dtype=np.float64)
        yS = np.array(self.yS, dtype=np.float64)
        if len(self.iS.shape)==1:
            iS = self.iS[:,np.newaxis].astype(np.float64)
        else:
            iS = self.iS.astype(np.float64)
        idx_sources = np.where(np.all(np.abs(iS) > 1e-8, axis=1))[0].tolist()

        # Call the optimized Numba function
        Bx, By, B = calculateMagneticField_Numba(xS, yS, iS, idx_sources, x0s, y0s)

        if len(self.iS.shape) == 1:
            Bx, By, B = Bx[:,0], By[:,0], B[:,0]

        return Bx, By, B


    def calculateMagneticFieldGrid(self, minMaxX: list, minMaxY: list, nGridPoints = [10, 10]) -> list:
        '''
            **Calculates magnetic field generated by the coil in a grid using Biot-Savart law**

            Returns X and Y components of the magnetic field, and its absolute value, for each point [T], and the X and
            Y positions of the grid points.

            :param minMaxX: Minimum and maximum positions of the grid in the X direction [m]
            :type minMaxX: list
            :param minMaxY: Minimum and maximum positions of the grid in the Y direction [m]
            :type minMaxY: list
            :param nGridPoints: Number of points in the grid, in the X and Y direction [-]
            :type nGridPoints: list

            :return: list
        '''

        # Assign current line positions and currents
        xS, yS, iS = self.xS, self.yS, self.iS

        # Convert list into numpy array
        x, y, I = map(np.array, (xS, yS, iS))

        # Calculate the grid positions
        x_map, y_map = np.meshgrid(np.linspace(minMaxX[0], minMaxX[1], nGridPoints[0]), np.linspace(minMaxY[0], minMaxY[1], nGridPoints[1]))

        # Calculation of the magnetic field in the strands, using Biot-Savart law
        nRows = len(x_map)
        nCols = len(x_map[0])
        Bx_map = np.zeros((nRows, nCols))
        By_map = np.zeros((nRows, nCols))
        B_map = np.zeros((nRows, nCols))
        for r in range(nRows):
            y0 = np.array([y_map[r, 1]]).astype(np.float64)
            for c in range(nCols):
                x0 = np.array([x_map[1, c]]).astype(np.float64)
                Bx_map[r, c], By_map[r, c], B_map[r, c] = self.calculateMagneticField(x0, y0)

        return Bx_map, By_map, B_map, x_map, y_map