# Licensed under a 3-clause BSD style license - see LICENSE.rst

# "test_ufunc.py" is auto-generated by erfa_generator.py from the template
# "test_ufunc.py.templ". Do *not* edit "test_ufunc.py" directly, instead edit
# "test_ufunc.py.templ" and run erfa_generator.py from the source directory to
# update it.

"""
Basic tests of the ERFA library routines.

These are just the tests bundled with ERFA itself, in ``t_erfa_c.c``,
but translated to python to make sure that the code returns the same numbers.

The viv and vid functions emulate the corresponding functions in ``t_erfa_c.c``.

The tests are skipped if a system library is used that does not match in
version number, since in that case the precise numbers may have changed
(e.g., due to the earth orientation changes between 1.7.2 and 1.7.3).
"""

import numpy as np
import pytest

import erfa
from erfa import ufunc as erfa_ufunc


if not erfa.__version__.startswith(erfa.version.erfa_version):
    pytest.skip("skipping for system library with mismatched version",
                allow_module_level=True)


def viv(ival, ivalok, func, test, _):
    """Validate an integer result."""
    assert ival == ivalok, f"{func} failed: {test} want {ivalok} got {ival}"


def vvd(val, valok, dval, func, test, _):
    """Validate a double result."""
    a = val - valok
    assert a == 0.0 or abs(a) <= abs(dval), (
        f"{func} failed: {test} want {valok:.20g} got {val:.20g} "
        f"(1/{abs(valok / a):.3g})")


status = np.zeros((), dtype=int)
# <--------------------------Actual test-wrapping code------------------------>
{%- for test in test_funcs %}


{% if test.xfail() -%}
@pytest.mark.xfail({{ test.xfail() }})
{% endif -%}
def test_{{ test.name }}():
    {%- for line in test.to_python() %}
    {{ line }}
    {%- endfor %}


{%- endfor %}


def test_status():
    assert status == 0, "Sanity check failed!"
{# done! (note: this comment also ensures final new line!) #}
