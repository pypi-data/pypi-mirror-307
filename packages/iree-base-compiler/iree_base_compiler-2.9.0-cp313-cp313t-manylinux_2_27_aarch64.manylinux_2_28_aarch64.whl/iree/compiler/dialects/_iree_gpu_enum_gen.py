
# Autogenerated by mlir-tblgen; don't manually edit.

from enum import IntEnum, auto, IntFlag
from ._ods_common import _cext as _ods_cext
from ..ir import register_attribute_builder
_ods_ir = _ods_cext.ir

class ComputeBitwidths(IntFlag):
    """Supported bitwidths for compute"""

    FP64 = 1
    FP32 = 2
    FP16 = 4
    Int64 = 8
    Int32 = 16
    Int16 = 32
    Int8 = 64

    def __iter__(self):
        return iter([case for case in type(self) if (self & case) is case])
    def __len__(self):
        return bin(self).count("1")

    def __str__(self):
        if len(self) > 1:
            return "|".join(map(str, self))
        if self is ComputeBitwidths.FP64:
            return "fp64"
        if self is ComputeBitwidths.FP32:
            return "fp32"
        if self is ComputeBitwidths.FP16:
            return "fp16"
        if self is ComputeBitwidths.Int64:
            return "int64"
        if self is ComputeBitwidths.Int32:
            return "int32"
        if self is ComputeBitwidths.Int16:
            return "int16"
        if self is ComputeBitwidths.Int8:
            return "int8"
        raise ValueError("Unknown ComputeBitwidths enum entry.")



@register_attribute_builder("IREEGPU_ComputeBitwidths")
def _ireegpu_computebitwidths(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class DotProductOps(IntFlag):
    """Supported dot product ops"""

    None_ = 0
    DP4xI8ToI32 = 1

    def __iter__(self):
        return iter([case for case in type(self) if (self & case) is case])
    def __len__(self):
        return bin(self).count("1")

    def __str__(self):
        if len(self) > 1:
            return "|".join(map(str, self))
        if self is DotProductOps.None_:
            return "none"
        if self is DotProductOps.DP4xI8ToI32:
            return "dp4xi8toi32"
        raise ValueError("Unknown DotProductOps enum entry.")



@register_attribute_builder("IREEGPU_DotProductOps")
def _ireegpu_dotproductops(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class MMAFragment(IntEnum):
    """Descriptor for a particular fragment of an MMA operation"""

    Lhs = 0
    Rhs = 1
    Acc = 2

    def __str__(self):
        if self is MMAFragment.Lhs:
            return "Lhs"
        if self is MMAFragment.Rhs:
            return "Rhs"
        if self is MMAFragment.Acc:
            return "Acc"
        raise ValueError("Unknown MMAFragment enum entry.")



@register_attribute_builder("IREEGPU_MMAFragment")
def _ireegpu_mmafragment(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class MMAIntrinsic(IntEnum):
    """Descriptor for different MMA intrinsics"""

    MFMA_F32_16x16x4_F32 = 2304
    MFMA_F32_16x16x16_F16 = 2320
    MFMA_F32_32x32x8_F16 = 2321
    MFMA_F32_16x16x16_BF16 = 2336
    MFMA_F32_32x32x8_BF16 = 2337
    MFMA_F32_16x16x32_F8E4M3FNUZ = 2368
    MFMA_F32_16x16x32_F8E5M2FNUZ = 2352
    MFMA_I32_16x16x32_I8 = 2432
    MFMA_I32_32x32x16_I8 = 2433
    MFMA_I32_16x16x16_I8 = 2176
    MFMA_I32_32x32x8_I8 = 2177
    WMMA_F32_16x16x16_F16 = 16
    WMMA_F16_16x16x16_F16 = 17
    WMMA_I32_16x16x16_I8 = 128

    def __str__(self):
        if self is MMAIntrinsic.MFMA_F32_16x16x4_F32:
            return "MFMA_F32_16x16x4_F32"
        if self is MMAIntrinsic.MFMA_F32_16x16x16_F16:
            return "MFMA_F32_16x16x16_F16"
        if self is MMAIntrinsic.MFMA_F32_32x32x8_F16:
            return "MFMA_F32_32x32x8_F16"
        if self is MMAIntrinsic.MFMA_F32_16x16x16_BF16:
            return "MFMA_F32_16x16x16_BF16"
        if self is MMAIntrinsic.MFMA_F32_32x32x8_BF16:
            return "MFMA_F32_32x32x8_BF16"
        if self is MMAIntrinsic.MFMA_F32_16x16x32_F8E4M3FNUZ:
            return "MFMA_F32_16x16x32_F8E4M3FNUZ"
        if self is MMAIntrinsic.MFMA_F32_16x16x32_F8E5M2FNUZ:
            return "MFMA_F32_16x16x32_F8E5M2FNUZ"
        if self is MMAIntrinsic.MFMA_I32_16x16x32_I8:
            return "MFMA_I32_16x16x32_I8"
        if self is MMAIntrinsic.MFMA_I32_32x32x16_I8:
            return "MFMA_I32_32x32x16_I8"
        if self is MMAIntrinsic.MFMA_I32_16x16x16_I8:
            return "MFMA_I32_16x16x16_I8"
        if self is MMAIntrinsic.MFMA_I32_32x32x8_I8:
            return "MFMA_I32_32x32x8_I8"
        if self is MMAIntrinsic.WMMA_F32_16x16x16_F16:
            return "WMMA_F32_16x16x16_F16"
        if self is MMAIntrinsic.WMMA_F16_16x16x16_F16:
            return "WMMA_F16_16x16x16_F16"
        if self is MMAIntrinsic.WMMA_I32_16x16x16_I8:
            return "WMMA_I32_16x16x16_I8"
        raise ValueError("Unknown MMAIntrinsic enum entry.")



@register_attribute_builder("IREEGPU_MMAIntrinsic")
def _ireegpu_mmaintrinsic(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class MMAScope(IntEnum):
    """Descriptor for a particular scope of an MMA operation"""

    Workgroup = 0
    Subgroup = 1

    def __str__(self):
        if self is MMAScope.Workgroup:
            return "Workgroup"
        if self is MMAScope.Subgroup:
            return "Subgroup"
        raise ValueError("Unknown MMAScope enum entry.")



@register_attribute_builder("IREEGPU_MMAScope")
def _ireegpu_mmascope(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class ReorderWorkgroupsStrategy(IntEnum):
    """Strategy for workgroup reordering"""

    None_ = 0
    Swizzle = 1
    Transpose = 2

    def __str__(self):
        if self is ReorderWorkgroupsStrategy.None_:
            return "None"
        if self is ReorderWorkgroupsStrategy.Swizzle:
            return "Swizzle"
        if self is ReorderWorkgroupsStrategy.Transpose:
            return "Transpose"
        raise ValueError("Unknown ReorderWorkgroupsStrategy enum entry.")



@register_attribute_builder("IREEGPU_ReorderWorkgroupsStrategy")
def _ireegpu_reorderworkgroupsstrategy(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class StorageBitwidths(IntFlag):
    """Supported bitwidths for storage"""

    B64 = 1
    B32 = 2
    B16 = 4
    B8 = 8

    def __iter__(self):
        return iter([case for case in type(self) if (self & case) is case])
    def __len__(self):
        return bin(self).count("1")

    def __str__(self):
        if len(self) > 1:
            return "|".join(map(str, self))
        if self is StorageBitwidths.B64:
            return "b64"
        if self is StorageBitwidths.B32:
            return "b32"
        if self is StorageBitwidths.B16:
            return "b16"
        if self is StorageBitwidths.B8:
            return "b8"
        raise ValueError("Unknown StorageBitwidths enum entry.")



@register_attribute_builder("IREEGPU_StorageBitwidths")
def _ireegpu_storagebitwidths(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class SubgroupOps(IntFlag):
    """Supported subgroup ops"""

    None_ = 0
    Shuffle = 1
    Arithmetic = 2

    def __iter__(self):
        return iter([case for case in type(self) if (self & case) is case])
    def __len__(self):
        return bin(self).count("1")

    def __str__(self):
        if len(self) > 1:
            return "|".join(map(str, self))
        if self is SubgroupOps.None_:
            return "none"
        if self is SubgroupOps.Shuffle:
            return "shuffle"
        if self is SubgroupOps.Arithmetic:
            return "arithmetic"
        raise ValueError("Unknown SubgroupOps enum entry.")



@register_attribute_builder("IREEGPU_SubgroupOps")
def _ireegpu_subgroupops(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class TilingLevel(IntEnum):
    """Descriptor for tiling levels for GPU lowering configs"""

    Workgroup = 0
    Reduction = 1
    PartialReduction = 2
    Thread = 3
    Subgroup = 4
    Lane = 5

    def __str__(self):
        if self is TilingLevel.Workgroup:
            return "Workgroup"
        if self is TilingLevel.Reduction:
            return "Reduction"
        if self is TilingLevel.PartialReduction:
            return "PartialReduction"
        if self is TilingLevel.Thread:
            return "Thread"
        if self is TilingLevel.Subgroup:
            return "Subgroup"
        if self is TilingLevel.Lane:
            return "Lane"
        raise ValueError("Unknown TilingLevel enum entry.")



@register_attribute_builder("IREEGPU_TilingLevel")
def _ireegpu_tilinglevel(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class VirtualMMAIntrinsic(IntEnum):
    """Descriptor for different Virtual MMA intrinsics"""

    VMFMA_F32_16x16x32_F16 = 2322
    VMFMA_F32_32x32x16_F16 = 2323
    VMFMA_F32_16x16x32_F8E4M3FNUZ = 2369

    def __str__(self):
        if self is VirtualMMAIntrinsic.VMFMA_F32_16x16x32_F16:
            return "VMFMA_F32_16x16x32_F16"
        if self is VirtualMMAIntrinsic.VMFMA_F32_32x32x16_F16:
            return "VMFMA_F32_32x32x16_F16"
        if self is VirtualMMAIntrinsic.VMFMA_F32_16x16x32_F8E4M3FNUZ:
            return "VMFMA_F32_16x16x32_F8E4M3FNUZ"
        raise ValueError("Unknown VirtualMMAIntrinsic enum entry.")



@register_attribute_builder("IREEGPU_VirtualMMAIntrinsic")
def _ireegpu_virtualmmaintrinsic(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

class IteratorType(IntEnum):
    """Iterator type"""

    parallel = 0
    reduction = 1

    def __str__(self):
        if self is IteratorType.parallel:
            return "parallel"
        if self is IteratorType.reduction:
            return "reduction"
        raise ValueError("Unknown IteratorType enum entry.")



@register_attribute_builder("IteratorType")
def _iteratortype(x, context):
    return _ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless(32, context=context), int(x))

@register_attribute_builder("IREEGPU_ComputeBitwidthsAttr")
def _ireegpu_computebitwidthsattr(x, context):
    return _ods_ir.Attribute.parse(f'#iree_gpu<compute_bitwidths {str(x)}>', context=context)

@register_attribute_builder("IREEGPU_DotProductOpsAttr")
def _ireegpu_dotproductopsattr(x, context):
    return _ods_ir.Attribute.parse(f'#iree_gpu<dotproduct_ops {str(x)}>', context=context)

@register_attribute_builder("IREEGPU_IteratorTypeEnum")
def _ireegpu_iteratortypeenum(x, context):
    return _ods_ir.Attribute.parse(f'#iree_gpu.iterator_type<{str(x)}>', context=context)

@register_attribute_builder("IREEGPU_MMAIntrinsicAttr")
def _ireegpu_mmaintrinsicattr(x, context):
    return _ods_ir.Attribute.parse(f'#iree_gpu<mma_intrinsic {str(x)}>', context=context)

@register_attribute_builder("IREEGPU_ReorderWorkgroupsStrategyAttr")
def _ireegpu_reorderworkgroupsstrategyattr(x, context):
    return _ods_ir.Attribute.parse(f'#iree_gpu.reorder_workgroups_strategy<{str(x)}>', context=context)

@register_attribute_builder("IREEGPU_StorageBitwidthsAttr")
def _ireegpu_storagebitwidthsattr(x, context):
    return _ods_ir.Attribute.parse(f'#iree_gpu<storage_bitwidths {str(x)}>', context=context)

@register_attribute_builder("IREEGPU_SubgroupOpsAttr")
def _ireegpu_subgroupopsattr(x, context):
    return _ods_ir.Attribute.parse(f'#iree_gpu<subgroup_ops {str(x)}>', context=context)

@register_attribute_builder("IREEGPU_VirtualMMAIntrinsicAttr")
def _ireegpu_virtualmmaintrinsicattr(x, context):
    return _ods_ir.Attribute.parse(f'#iree_gpu<virtual_mma_intrinsic {str(x)}>', context=context)

