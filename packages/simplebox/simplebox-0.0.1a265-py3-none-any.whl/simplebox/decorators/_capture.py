#!/usr/bin/env python
# -*- coding:utf-8 -*-
from collections.abc import Callable
from functools import wraps
from typing import Union, Any

from ._hook import _run_hook_func
from ._process import _do
from ..generic import T

_ExceptionTypes = Union[type[Exception], tuple[type[Exception]], None]


def capture(exception: _ExceptionTypes = BaseException, post: Callable = None) -> T:
    """
    Catch exceptions to decorated functions, including exceptions generated by other decorators.

    callback functions can and only support communication via the chain keyword parameter. example: callback() is ok,
    callback(chain=None) is ok, callback(chain=None, other=None) is ok(other arg will not be assigned), callback(other, chain=None) will happend exception

    :param post while callback function when happen exception
    :param exception: The base type exception to the exception that needs to be caught. After capture,
                    the exception will be "eaten" directly, and exception outside this range will be thrown.
    """
    def _inner(func):
        @wraps(func)
        def _wrapper(*args, **kwargs):
            return _do(func=func, decorator_name=capture.__name__, args=args, kwargs=kwargs,
                       opts={"exception": exception, "post": post, "args": args, "kwargs": kwargs, "stacklevel": 7})

        return _wrapper

    return _inner


def __do_capture(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None) -> Any:
    exception: _ExceptionTypes = opts.get("exception")
    post: Callable = opts.get("post")
    args_ = args or ()
    kwargs_ = kwargs or {}
    try:
        return func(*args_, **kwargs_)
    except BaseException as e:
        if issubclass(type(exception), list):
            e_type = type(e)
            for e_ in exception:
                if not issubclass(e_type, e_):
                    raise
        else:
            if not issubclass(type(e), exception):
                raise
    finally:
        if post:
            _run_hook_func([post], args, kwargs, opts.get("srcFuncClass", ""))


__all__ = []
