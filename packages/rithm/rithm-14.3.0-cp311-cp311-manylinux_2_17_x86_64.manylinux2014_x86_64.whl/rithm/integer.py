from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Any, overload

    from typing_extensions import Self

    from .enums import Endianness
    from .fraction import Fraction

    class Int:
        @property
        def denominator(self, /) -> Self: ...

        @property
        def numerator(self, /) -> Self: ...

        def bit_length(self, /) -> Self: ...

        def gcd(self, other: Self, /) -> Self: ...

        def is_power_of_two(self, /) -> bool: ...

        def to_bytes(self, endianness: Endianness, /) -> bytes: ...

        @classmethod
        def from_bytes(
            cls, value: bytes, endianness: Endianness, /
        ) -> Self: ...

        @overload
        def __new__(cls, value: Self | float | int = ..., /) -> Self: ...

        @overload
        def __new__(cls, value: str, base: int | None = ..., /) -> Self: ...

        def __new__(
            cls,
            value: Self | float | int | str = ...,
            base: int | None = ...,
            /,
        ) -> Self: ...

        def __abs__(self, /) -> Self: ...

        def __add__(self, other: Self | int, /) -> Self: ...

        def __and__(self, other: Self | int, /) -> Self: ...

        def __bool__(self, /) -> bool: ...

        def __ceil__(self, /) -> Self: ...

        def __divmod__(self, other: Self | int, /) -> tuple[Self, Self]: ...

        @overload
        def __eq__(self, other: Self | int, /) -> bool: ...

        @overload
        def __eq__(self, other: Any, /) -> Any: ...

        def __eq__(self, other: Any, /) -> Any: ...

        def __float__(self, /) -> float: ...

        def __floor__(self, /) -> Self: ...

        def __floordiv__(self, other: Self | int, /) -> Self: ...

        def __ge__(self, other: Self | int, /) -> bool: ...

        def __reduce__(self, /) -> tuple[tuple[Self], tuple[int]]: ...

        def __gt__(self, other: Self | int, /) -> bool: ...

        def __hash__(self, /) -> int: ...

        def __index__(self, /) -> int: ...

        def __int__(self, /) -> int: ...

        def __invert__(self, /) -> Self: ...

        def __le__(self, other: Self | int, /) -> bool: ...

        def __lshift__(self, other: Self | int, /) -> Self: ...

        def __lt__(self, other: Self | int, /) -> bool: ...

        def __mod__(self, other: Self | int, /) -> Self: ...

        def __mul__(self, other: Self | int, /) -> Self: ...

        def __neg__(self, /) -> Self: ...

        def __or__(self, other: Self | int, /) -> Self: ...

        def __pos__(self, /) -> Self: ...

        def __pow__(
            self, exponent: Self | int, divisor: Self | None | int = ..., /
        ) -> Fraction | Self: ...

        def __radd__(self, other: int, /) -> Self: ...

        def __rand__(self, other: int, /) -> Self: ...

        def __rdivmod__(self, other: int, /) -> tuple[Self, Self]: ...

        def __repr__(self, /) -> str: ...

        def __rfloordiv__(self, other: int, /) -> Self: ...

        def __rlshift__(self, other: int, /) -> Self: ...

        def __rmod__(self, other: int, /) -> Self: ...

        def __rmul__(self, other: int, /) -> Self: ...

        def __ror__(self, other: int, /) -> Self: ...

        def __round__(self, digits: int | None = ..., /) -> Self: ...

        def __rpow__(
            self, base: int, divisor: Self | None | int = ..., /
        ) -> Fraction | Self: ...

        def __rrshift__(self, other: int, /) -> Self: ...

        def __rshift__(self, other: Self | int, /) -> Self: ...

        def __rsub__(self, other: int, /) -> Self: ...

        def __rtruediv__(self, other: int, /) -> Fraction: ...

        def __rxor__(self, other: int, /) -> Self: ...

        def __str__(self, /) -> str: ...

        def __sub__(self, other: Self | int, /) -> Self: ...

        def __truediv__(self, other: Self | int, /) -> Fraction: ...

        def __trunc__(self, /) -> Self: ...

        def __xor__(self, other: Self | int, /) -> Self: ...

else:
    try:
        from . import _crithm as _module
    except ImportError:
        from . import _rithm as _module

    Int = _module.Int

    del _module
