import dataclasses
from typing import List, Optional

from databricks.rag_eval.utils import error_utils, token_counting_utils
from databricks.rag_eval.utils.collection_utils import deep_getattr, deep_setattr
from databricks.rag_eval.utils.enum_utils import StrEnum


class DocsRenderMode(StrEnum):
    DOCS_RENDER_MODE_UNSPECIFIED = "DOCS_RENDER_MODE_UNSPECIFIED"
    HTML = "HTML"
    MARKDOWN = "MARKDOWN"


class EvalMode(StrEnum):
    EVAL_MODE_UNSPECIFIED = "EVAL_MODE_UNSPECIFIED"
    EVAL_MODE_FEEDBACK = "EVAL_MODE_FEEDBACK"
    EVAL_MODE_GRADING_NOTES = "EVAL_MODE_GRADING_NOTES"
    EVAL_MODE_GROUND_TRUTH = "EVAL_MODE_GROUND_TRUTH"
    EVAL_MODE_EXPECTED_FACTS = "EVAL_MODE_EXPECTED_FACTS"
    EVAL_MODE_EXPECTED_RESPONSE = "EVAL_MODE_EXPECTED_RESPONSE"


@dataclasses.dataclass
class EvalsInstance:
    instance_id: Optional[str] = None
    eval_mode: Optional[EvalMode] = None  # Deprecated
    docs_table_name: Optional[str] = None
    primary_key_col_name: Optional[str] = None
    content_col_name: Optional[str] = None
    docs_render_mode: Optional[DocsRenderMode] = None
    agent_name: Optional[str] = None
    model_serving_endpoint_name: Optional[str] = None
    version: Optional[str] = None  # Deprecated

    @staticmethod
    def _field_locations():
        return [
            ("instance_id", ("instance_id",), None),
            ("eval_mode", ("eval_mode",), EvalMode),
            (
                "docs_table_name",
                ("corpus_config", "docs_table_config", "docs_table_name"),
                None,
            ),
            (
                "primary_key_col_name",
                ("corpus_config", "docs_table_config", "primary_key_col_name"),
                None,
            ),
            (
                "content_col_name",
                ("corpus_config", "docs_table_config", "content_col_name"),
                None,
            ),
            (
                "docs_render_mode",
                ("corpus_config", "docs_table_config", "docs_render_mode"),
                DocsRenderMode,
            ),
            ("agent_name", ("agent_config", "agent_name"), None),
            (
                "model_serving_endpoint_name",
                ("agent_config", "model_serving_config", "model_serving_endpoint_name"),
                None,
            ),
            ("version", ("version",), None),
        ]

    @staticmethod
    def from_json(json: dict) -> "EvalsInstance":
        values = {}
        for field_name, field_location, enum in EvalsInstance._field_locations():
            raw_value = deep_getattr(json, field_location)
            if raw_value is not None and enum is not None:
                raw_value = enum(raw_value)
            values[field_name] = raw_value
        return EvalsInstance(**values)

    def to_json(self) -> dict:
        output = {}
        for field_name, field_location, enum in EvalsInstance._field_locations():
            value = getattr(self, field_name)
            if value is not None:
                deep_setattr(output, field_location, (value.value if enum else value))
        return output

    def get_fieldmask(self) -> str:
        return ",".join(
            ".".join(field_location)
            for field_name, field_location, _ in EvalsInstance._field_locations()
            if getattr(self, field_name) is not None and field_name != "instance_id"
        )


@dataclasses.dataclass
class Document:
    """A document that holds the source data for an agent application."""

    content: str
    """The raw content of the document."""

    doc_uri: str
    """The URI of the document."""

    num_tokens: Optional[int] = None
    """The number of tokens in the document."""

    def __post_init__(self):
        if not self.content or not isinstance(self.content, str):
            raise error_utils.ValidationError(
                f"'content' of a document must be a non-empty string. Got: {self.content}"
            )

        if not self.doc_uri or not isinstance(self.doc_uri, str):
            raise error_utils.ValidationError(
                f"'doc_uri' of a document must be a non-empty string. Got: {self.doc_uri}"
            )

        if self.num_tokens is None:
            self.num_tokens = token_counting_utils.count_tokens(self.content)


@dataclasses.dataclass
class SyntheticQuestion:
    """A synthetic question generated by the synthetic API that can be used for evaluation."""

    question: str
    """The raw question text."""

    source_doc_uri: str
    """The URI of the document from which the question was generated."""

    source_context: str
    """
    The context from which the question was generated. 
    Could be a chunk of text from the source document or the whole document content.
    """


@dataclasses.dataclass
class SyntheticAnswer:
    """A synthetic answer generated by the synthetic API that can be used for evaluation."""

    question: SyntheticQuestion
    """The synthetic question to which the answer corresponds."""

    synthetic_ground_truth: Optional[str] = None
    """The synthetic ground truth answer for the question."""

    synthetic_grading_notes: Optional[str] = None
    """The synthetic grading notes to help judge the correctness of the question."""

    synthetic_minimal_facts: Optional[List[str]] = None
    """The synthetic minimum expected facts required to answer the question."""


class SyntheticAnswerType(StrEnum):
    GROUND_TRUTH = "GROUND_TRUTH"
    GRADING_NOTES = "GRADING_NOTES"
    MINIMAL_FACTS = "MINIMAL_FACTS"
